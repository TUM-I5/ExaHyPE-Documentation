<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/d44/page_multigrid_terminology.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Terminology and degree of freedom layout</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In all of our methods, we work with Lagrangian polynomials. The solution results from a linear combination of weighted polynomials spanning function spaces. The weights determine the continuous solution. We have quite some freedom how to arrange the weights geometrically and to pick polynomials. The sketch below depits a Gauss-Legendre (left) and Gauss-Lobatto (right) arrangement. We also note that in general, we store variables one after another, ie we store the values for \( u \) for each node on the facet, then each value for \( p_x \) etc.</p>
<div class="image">
<img src="../../GaussLobatto.png" alt=""/>
</div>
<div style="background-color: #cfc ; padding: 10px; border: 1px solid green;"> We refer to the points which host weights of Lagrangian polynomials as <em><b>nodes</b></em>. Each node can hold multiple <em><b>unknowns</b></em> which are weights of the shape functions. </div><p>If we look at one cell, the number of nodes times the number of unknowns defines the total number of <em><b>degrees of freedom</b></em> (DoFs) within the system. We frequently also introduce function spaces on facets and vertices. Those guys have their own nodes and unknowns. It really depends on the numerical scheme if the resulting weights are real degrees of freedom or sole helpers.</p>
<p>We note that for Lobatto, some cell nodes coincide spatially with the faces. However, we hold all the data within the cells (from a data structure point of view). As we store all the unknowns of all degrees of freedom per cell in one huge array per cell, we end up with an array of doubles of size \( K (p+1)^d \), \( K \) being the number of unknowns per cell node and \( p \) denoting the polynomial order.</p>
<div style="background-color: #cfc ; padding: 10px; border: 1px solid green;"> A solver in Peano has a unique geometric layout of its nodes, and each and every node holds the same number of unknowns (though some solvers allow you to change the number of unknowns held by cells, facets and vertices). If you need different node layouts (polynomial orders), you can combine various solvers with different layouts. The overall philosophy is to keep things simple as building blocks, which users can assemble into more complex code setups. An alternative approach would have been to write one generic, monolithic solver with a lot of features which cover all eventualities and then can be specialised. </div><h1><a class="anchor" id="autotoc_md986"></a>
Enumeration Order</h1>
<p>Here we provide some details on the way Peano enumerates its vertices and faces. It is an enumeration pattern that works in any number of dimensions. In many situations that we aim to solve, each of our faces and cells will have multiple degrees of freedom upon them, and we shall reuse this enumeration order to allow users to figure out their spatial ordering.</p>
<h2><a class="anchor" id="autotoc_md987"></a>
Vertex Enumeration</h2>
<p>First we describe how the vertices are enumerated in 2D and 3D, before describing how we reuse this pattern in higher dimensions.</p>
<p>See:</p>
<div class="image">
<img src="../../VertexEnumerator.png" alt=""/>
</div>
<p>Our general pattern is:</p>
<ul>
<li>x axis, y axis then z axis, greedily assigning indices until each axis is saturated </li>
<li>Left, bottom and then front first</li>
</ul>
<p>We describe this pattern, first in 2D. Let our vertices lie in the (x,y) plane. Assign vertices as follows:</p>
<ol type="1">
<li>We assign index 0 to the vertex which has the "most negative" x and y coordinates, ie the vertex in the bottom left<br  />
</li>
<li>We then move along the x axis, assigning indices until this axis is saturated (ie we move to the right, and assign index 1). We then return to the vertex at which we began at the start of this step. <br  />
</li>
<li>We then take one step along the y axis, assigning index 2. <br  />
</li>
<li>We repeat step 2, until this axis is saturated (ie, move to the right and assign index 3). Return to the index where we began this step.</li>
</ol>
<p>In 2D we are now done.</p>
<p>In 3D, it's much the same. We undertake steps 1-4 as above, before returning to vertex 0. Then, take a step in the z direction, and repeat steps 1-4 again.</p>
<p>Note that if we have some 4th dimension w, all we need to do is repeat these steps again along this dimension, greedily assigning indices along the x axis first, and then the y axis etc.</p>
<p>This pattern is exactly the same as described in <a class="el" href="../../d2/d29/structpeano4_1_1datamanagement_1_1VertexEnumerator.html" title="Vertex enumerator within array.">peano4::datamanagement::VertexEnumerator</a>.</p>
<h2><a class="anchor" id="autotoc_md988"></a>
Face Enumeration</h2>
<p>The face enumeration follows <a class="el" href="../../dc/da6/classpeano4_1_1datamanagement_1_1FaceEnumerator.html" title="Enumerator over an array of faces.">peano4::datamanagement::FaceEnumerator</a>.</p>
<div class="image">
<img src="../../FaceEnumerator.png" alt=""/>
</div>
<p>We proceed with a similar pattern to vertices, except we use the direction of the normal of a face plus the left/right decision as primary metric. First, we assign the index 0 to the face whose unit normal points in the negative x direction. We assign the next index to the face whose unit normal points in the negative y direction, before assigning the next to the face that points in the negative z direction.</p>
<p>Following this, we assign subsequent indices to the faces who unit normal vectors point in the positive x, y and then z directions. This extends to any number of dimensions, as long as the dimensions are strictly ordered (x, y, z, etc)</p>
<h2><a class="anchor" id="autotoc_md989"></a>
Degree of freedom enumeration on cells</h2>
<p>Here we once again have a similar pattern.</p>
<ol type="1">
<li>Start with the DoF that is positioned with the most negative (x,y,z) coordinates.<br  />
</li>
<li>Move along the x axis, assigning indices until saturated. Once complete, return to the index first encountered at the start of this step.<br  />
</li>
<li>Take one step along the y axis, and repeat step 2. Once complete, return to the index first encountered at the start of this step. <br  />
</li>
<li>Repeat steps 2 and 3 until the (x,y) plane of this layer is saturated.<br  />
</li>
<li>Return to where we began. Take one step in the z direction, and repeat steps 2-4 until saturated.</li>
</ol>
<p>The final product should look something like this:</p>
<div class="image">
<img src="../../dof-ordering-within-cell.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md990"></a>
Degree of freedom enumeration on faces</h2>
<p>Faces usually hold three types of unknowns:</p>
<ol type="1">
<li>Left projections (left along the respective Cartesian coordinate axis parallel to the face's normal);</li>
<li>Right projections;</li>
<li>Solutions to a flux formulation or averages.</li>
</ol>
<p>All the data on a face are organised in one big memory chunk per face. The first part of this chunk holds left data, the next one right data, and finally the third type of information. Left and right data chunk have the same size.</p>
<div class="image">
<img src="../../face-ordering.png" alt=""/>
</div>
<h1><a class="anchor" id="autotoc_md991"></a>
Mathematical notation</h1>
<h2><a class="anchor" id="autotoc_md992"></a>
Reserved letters</h2>
<ul>
<li>\( d \in \{2,3\} \) is the dimension of the spatial problem.</li>
<li>\( p \geq 0 \) denotes a polynomial order.</li>
</ul>
<h2><a class="anchor" id="autotoc_md993"></a>
Symbols</h2>
<ul>
<li>Constants are written as uppercase letters such as \( K \). Usually, they are scalars. An exceptions to this rule is \( \omega &gt;0 \) which we use in line with popular literature as damping/relaxation factor.</li>
<li>Lowercase letters such as \( u \) denote a function if they are used within a <a class="el" href="../../da/db8/namespacePDE.html">PDE</a>, or <em><b>weights</b></em> within a <em><b>degree of freedom</b></em> if they are used within a matrix equation. It depends on the context is they are scalar PDEs or vector-valued PDEs or scalars or weight vectors, respectively, i.e. we do not use any syntax to highlight such a distinction. Our most popular choices for these guys are \( u \) and \( p \).</li>
<li>If we introduce "artificial" solver spaces/functions, we typically use Greek letters \( \lambda, \varphi, \cdots \). These are proper functions. They just do not appear in the original problem formulation (<a class="el" href="../../da/db8/namespacePDE.html">PDE</a>).</li>
<li>Matrices are written with uppercase symbols and bold, i.e.~ \( \mathbf{A} \) or \( \mathbf{P} \). The bold type distinguishes them from constants.</li>
<li>Usually, we use \( \mathbf{A} \) for system matrices (acting on some unknowns), \( \mathbf{P} \) for projection matrices (mapping one set of unknowns onto another one) and \( \mathbf{M} \) for matrices acting on other quantities. The choice of \( \mathbf{M} \) is inspired by the term mass matrix, which we traditionally find on the right-hand side.</li>
<li>Partial differential operators are written as \( \mathcal{L} \) or \( \mathcal{A} \) or similar, unless there are well-established symbols such as \( \nabla \) or \( \Delta \). The most frequently used identifiers are \( \mathcal{L} \) for the linear(ised) operator within the <a class="el" href="../../da/db8/namespacePDE.html">PDE</a>, and \( \mathcal{R} \) as generic symbol for a Riemann solver.</li>
<li>If we have to deal with individual shape/trial functions, we abstain from Greek letters ( \( \phi, \psi \) and \( \varphi \) are frequently found in literature) but instead favour \( v, q, \dots \).</li>
<li>We write integrators as \( \int ... d\boldsymbol{x} \) and surface integrals as \( \int ... d\boldsymbol{x} \). <br  />
</li>
</ul>
<h2><a class="anchor" id="autotoc_md994"></a>
Specifiers</h2>
<p>Often, symbols are subject to some further clarification or additional specification:</p>
<ul>
<li>To highlight that a matrix or function acts on a cell or face, we use a superscript \( ^c \) or \( ^f \) respectively. \( u^c \) consequently denotes a function or weights, but the superscript highlights that they live on cells only.</li>
<li>If we have a projection (or literally any matrix/operator) and want to highlight from where to where it maps, we write this as \( P_{f \gets c} \). This projection \( P \) takes a cell representation and yields a face representation.</li>
<li>A bar over a letter is used to distinguish between a function and a finite set of its values in the context of discretization. For example, if \( u = u(x,y) \) is a function defined on a 2D domain, \( \bar{u} \) can be used to denote a set of nodal values of \( u(x,y) \). (or should we use \( \textbf{u} \) insted?)</li>
</ul>
<h2><a class="anchor" id="autotoc_md995"></a>
Function manipulators</h2>
<ul>
<li>If we have a face where a function \( u \) does not exist, but there is a valid \( u \) left and right, \( u^- \) denotes this left function, while \( u^+ \) denotes the right one.</li>
<li>The modifier \( \hat{u} \) or \( \widehat{ \nabla u} \) on a function denotes that this function does not exist at the point where we evaluate it. However, there is are two valid function values - typically left and right - and this is the average.</li>
<li>Square double brackets denote the jump between two values: \( [\![ u ]\!] = u^- - u^+ \)</li>
<li>Curly brackets denote the average values: \( \{ u \} = \left( u^- + u^+ \right) / 2 \)</li>
<li>If a function lives on a cell, but we evaluate it only along the face, we use \( u|_f \). This means that we don't project it. We literally evaluate it. In this sense \( u^+ = u_c|_f \) where the \( u_c \) is the solution over the right adjacent cell of a face.</li>
</ul>
<h1><a class="anchor" id="autotoc_md996"></a>
Operator notation</h1>
<h2><a class="anchor" id="autotoc_md997"></a>
Face to cell (or "cell from face")</h2>
<p>When you project from the faces to the cell data, you will get 2d chunks of face data which are dumped into one big array. All the data is then projected in one rush into the cells. If both the cell and the face hold \( p+1 \) unknows per coordinate axis, and each cell node (cmp <a class="el" href="../../de/d44/page_multigrid_terminology.html">the generic multigrid terminology</a>) holds \( K^c \) unknowns, while each face node holds \( K^f \) unknowns, the projection is formalised through</p>
<p>\(
  x^c = P_{c \leftarrow f} x^f
\)</p>
<p>with \( P_{c \leftarrow f} \in \mathbb{R} ^{ K^c(p+1)^d \times 2dK^f(p+1)^{d-1} } \). The chunks within the \( 2dK^f(p+1)^{d-1} \) vector on the right are grouped following the face enumeration convention from above.</p>
<h2><a class="anchor" id="autotoc_md998"></a>
Cell to face (or "face from cell")</h2>
<p>When you project from a cell to its faces, you use</p>
<p>\(
  x^\pm = P_{f \leftarrow c} x^c
\)</p>
<p>with \( P_{f \leftarrow c} \in \mathbb{R} ^{ 2dK^f(p+1)^{d-1} \times K^c(p+1)^d } \). This time, the \( 2d \) chunks within the left-hand vector are either the \( x^+ \) or the \( x^- \) quantities on the cell, i.e. left or right projections. It is Peano's multigrid backend which has to ensure that you see only those chunks that are visible "from within the cell".</p>
<h2><a class="anchor" id="autotoc_md999"></a>
Face-face operation</h2>
<p>When you phrase operations on the faces, you typically get the left and the right projection in and you return an approximation of either the flux or the real value along the face. Conceptually, we often write this as</p>
<p>\( 
  x^f = A_{ff} \begin{bmatrix} x^- \\ x^+ \end{bmatrix}
\) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d3/da3/page_multigrid_home.html">MGHyPE</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:05 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
