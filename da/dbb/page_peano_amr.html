<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/dbb/page_peano_amr.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Adaptive Mesh Refinement (AMR)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Peano's AMR philosophy is guided by few simple principles:</p>
<ol type="1">
<li>The user recommends mesh properties, and Peano will produce a mesh that is at least as fine as requested. However, the code might decide to work with a finer mesh than requested for various reasons: To create full trees, to avoid topology changes between MPI, and so forth.</li>
<li>Peano adds or removes at most one mesh level at a time.</li>
<li>Peano does not use separate remeshing grid sweeps, i.e. the dynamic adaptivity is integrated into the normal mesh traversals that you also can use to implement your solver's functionality.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1009"></a>
AMR workflow and semantics</h2>
<p>All AMR instructions in Peano are formalised via objects of the type <a class="el" href="../../dd/de7/structpeano4_1_1grid_1_1GridControlEvent.html">peano4::grid::GridControlEvent</a>. Each event spans a certain geometric area and is either a refine or an erase event. I try to speak of refine and erase and not of refine and coarsen, as the latter is a term used in a multigrid context and usually means that you still keep the fine data somewhere. In contrast, Peano's erase means that the grid is really thrown away.</p>
<h3><a class="anchor" id="autotoc_md1010"></a>
Realisation</h3>
<p>Prior to each mesh traversal, the automaton running through the mesh asks the active observer hosting one or multiple <a class="el" href="../../da/d1b/peano_action_sets.html">action sets</a> for a list of grid control events. While is runs through the mesh, it takes these events into account. This happens in three steps:</p>
<ol type="1">
<li>Each subpartition asks the action set (clone) for the refinement and coarsening decisions at the startup of the mesh traversal. For this, they query <code>getGridControlEvents()</code>. Before we use the events, they are merged/consolidated by <a class="el" href="../../d7/d7c/namespacepeano4_1_1grid.html#abbcd0020ab00eb8d8679323040a08962" title="Merge set of refinement/coarsening commands.">peano4::grid::merge()</a>.</li>
<li>The mesh traversal uses this information to trigger erases or refinements.</li>
<li>In the subsequent mesh traversal, the mesh is actually altered.</li>
</ol>
<h3><a class="anchor" id="autotoc_md1011"></a>
Instruction semantics</h3>
<p>The semantics behind the different grid control flags is natural:</p>
<ul>
<li><em><b>refine</b></em> spans a certain area and hosts a mesh size h. The area spanned should be refined once unless it already hosts a mesh where the spacetree's octant size is already smaller than h.</li>
<li><em><b>erase</b></em> spans a certain area and hosts a mesh size h. The area spanned should be erased unless it would yield a mesh which is coarser than h.</li>
</ul>
<p>As we work with "at least" semantics all the way through, any refine event overwrites any erase event.</p>
<h2><a class="anchor" id="autotoc_md1012"></a>
Realisation in the code</h2>
<h3><a class="anchor" id="autotoc_md1013"></a>
or-based refinement and refinement arguments</h3>
<p>In Peano, a cell is refined, if one of its vertices carries a refinement flag. That is, we flag vertices (not cells), and the cells are refined if the or combination over all vertices yields true.</p>
<p>Consequently, we adhere to the following AMR paradigms:</p>
<ul>
<li>All vertices of a cell are set to refine if<ol type="1">
<li>the cell overlaps with a refine instruction; and</li>
<li>the cells' size h is bigger than the refine instruction's mesh size.</li>
</ol>
</li>
<li>All vertices of a cell are set to coarsen if<ol type="1">
<li>the cell plus all vertex-connected neighbours are completely covered by a erase event; and</li>
<li>the cell's size h is smaller than the erase instruction's mesh size.</li>
</ol>
</li>
</ul>
<p>This behaviour is realised within <a class="el" href="../../df/df6/classpeano4_1_1grid_1_1Spacetree.html#a9d5fcd0227a21505b358dde6c3d3b039" title="Should only be called for inner cells.">peano4::grid::Spacetree::evaluateGridControlEvents()</a>.</p>
<h3><a class="anchor" id="autotoc_md1014"></a>
Implication</h3>
<p>We study two examples of refinement instructions. In the first example, we start from a regular grid (top) and one refinement instruction specifying that a certain area - in this case not aligned with the grid et al should have a smaller mesh size.</p>
<div class="image">
<img src="../../amr-example00.png" alt=""/>
</div>
<p>Four cells overlap with the refinement instruction. They set their vertices to refinement-triggered, i.e. nine vertices in total are set to refine. As we have an or-based refinement criterion, this means that all the blueish cells are refined plus the orange ones around them. We end up with the mesh at the bottom.</p>
<p>In the second example, we have an adaptive mesh where an erase condition is imposed with a target mesh size which is just slightly coarser than the h of the right part of the grid.</p>
<div class="image">
<img src="../../amr-example01.png" alt=""/>
</div>
<p>Only refined cells which are overlapped by the erase command together with all of their neighbours are erase candidates. They are marked in blueish, with their adjacent neighbours marked as yellow. Note that Peano thinks in terms of trees and mesh hierarchies. The sketch shows the arising fine grid, but the decision to erase is made on the next coarser mesh within the tree. We end up with four vertices which hold the erase-triggered flag.</p>
<p>As we have an or-based refinement, erasing the vertices means that effectively only the three cells in the centre are coarsened. The other cells remain refined with a lot of adjacent hanging vertices.</p>
<h2><a class="anchor" id="autotoc_md1015"></a>
Using the dynamic mesh refinement</h2>
<h3><a class="anchor" id="autotoc_md1016"></a>
Multi-action set usage pattern</h3>
<p>In many  applications, the refinement pattern is not known a priori. Instead, the action sets build up the knowledge where to refine or coarsen: They start with an empty <code>std::vector&lt; <a class="el" href="../../dd/de7/structpeano4_1_1grid_1_1GridControlEvent.html">peano4::grid::GridControlEvent</a> &gt;</code>, and push back events throughout the grid run-through. As action sets are not persistent in-between mesh traversal sweeps, as codes might switch between different action sets, and as  clones one action set per subdomain (again, the number of subdomains per rank can change over time), we have to be careful with the data management.</p>
<p>A popular pattern is to have a static <code>std::vector&lt; <a class="el" href="../../dd/de7/structpeano4_1_1grid_1_1GridControlEvent.html">peano4::grid::GridControlEvent</a> &gt;</code>. In this case, an action set can build up a local set of control events, and commit them to the static set. The static set is then returned by <code>getGridControlEvents()</code> which consequently erases it to accept new events.</p>
<p>To make this work, you might want to work with two static sets: the currently active one and a new one, as each subspacetree will query <code>getGridControlEvents()</code> independently. However, we can exploit the fact that each subtree/subdomain asks for the grid control events before they actually trigger <code>beginIteration()</code>. So it is safe to hand out the static set and to clear it within the begin iteration.</p>
<p>If you work with multiple action sets and an algorithm which switches between the different ones, you will have to centralise the static control events. One action set might feed into the event, while the next one delivers from this centralised repository. Alternatively, you can add another (static) boolean which you set to true whenever <code>getGridControlEvents()</code> is invoked. The central events are then cleared by <code>beginIteration()</code> if and only if the boolean is set.</p>
<h3><a class="anchor" id="autotoc_md1017"></a>
Parallelisation</h3>
<p>Peano does not reduce the grid control events globally. That is, if you have multiple MPI ranks, you have to ensure they exchange their information with each other. If they don't each MPI rank will refine and erase their area independently. The mesh will still be consistent, as a vertex along a boundary which is refined will also trigger a refinement in the remote neighobur (or-based refinement policy), but there is no global data exchange. There is a routine <a class="el" href="../../d7/d7c/namespacepeano4_1_1grid.html#a1b5d1ada6b2272e51b8984187dd75f8c" title="Peano 4 does not reduce any grid control events globally.">peano4::grid::reduceGridControlEvents()</a> that allows you to reduce information.</p>
<h3><a class="anchor" id="autotoc_md1018"></a>
Refining the mesh</h3>
<p>Due to the or-based refinement criterion, refine instructions tend to spread through the mesh quite quickly. I therefore recommend that you scale the refine command down, i.e. make it only cover fragments of a cell. At the same time, it makes sense to ensure that two cells which trigger a refinement also trigger two refinement events which are adjacent, as this allows <a class="el" href="../../d7/d7c/namespacepeano4_1_1grid.html#abbcd0020ab00eb8d8679323040a08962" title="Merge set of refinement/coarsening commands.">peano4::grid::merge()</a> to merge them into one larger refinenet instructions. So, as a rule of thumb, I usually recommend to make refinement events span a mesh size which is around 95% of a cell. The <a class="el" href="../../d7/d7c/namespacepeano4_1_1grid.html#abbcd0020ab00eb8d8679323040a08962" title="Merge set of refinement/coarsening commands.">peano4::grid::merge()</a> operation, by default, works with 10% inaccuracy and then is still able to merge refinement events triggered by adjacent mesh cells.</p>
<h3><a class="anchor" id="autotoc_md1019"></a>
Coarsening the mesh</h3>
<p>Coarsening a mesh is tricky, as coarsening areas have to span quite some cells to actively remove mesh cells. This is a natural consequence of Peano's "at least" policy. At the same time, you want a coarsening never ever to eliminate a mesh part that you want, as this might need to oscillations where you erase and refine and erase again, while it also should not be cancelled out by a refine event "accidentially".</p>
<p>To enable Peano to erase safely, I usually identify refine cells of which I want to remove the children, and then I trigger an erase event which has three times the side line of this very cell. That is, if a cell has the mesh size h, the erase event has the size 3Ch where the C is a value slightly larger than 1. I often use 3.1h overall. This means that a cell tells Peano "hey, please
erase my children and the children of the neighbours".</p>
<p>Working with these extremely aggressive coarsening factors is important for refinement patterns which are non hexahedral, and it is important along domain boundaries, where we cannot hope that a neighbour concatenates their erase command to ours. Yet, while this will eliminate small refined patches that might have been left out or are close to the boundary, such an aggressive erase will leed to oscillations, as we might now ask for an erase over a cell which we actually wanna keep. <br  />
</p>
<p>To avoid oscillations, you can introduce a "keep this mesh" event through artificial refinement instructions. Refinements overwrite erase instructions. Therefore, you can always trigger a refinement event for a cell which actually does not refine this cell any further (just make the event span the whole cell with the cell's mesh size as target mesh size).</p>
<p>Such a refinement event does not refine the mesh any further. However, it prevents any erase event to remove this part of the mesh. So it is effectively a "keep the mesh" instruction.</p>
<h3><a class="anchor" id="autotoc_md1020"></a>
Optimisation</h3>
<p>Consult <a class="el" href="../../da/d8a/page_peano_performance_optimisation.html">the generic optimisation remarks</a> for some details around performance flaws tied to dynamic mesh refinement. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../dd/da2/page_peano4_home.html">Peano 4</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:05 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
