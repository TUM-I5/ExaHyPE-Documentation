<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/d26/page_exahype_gpu.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">GPU support (and aggressive vectorisation)</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md872">Compile with GPU support</a></li>
<li class="level1"><a href="#autotoc_md873">Enable stateless compute kernels</a><ul><li class="level2"><a href="#autotoc_md874">Provide the additional PDE terms without state</a></li>
<li class="level2"><a href="#autotoc_md875">Alter compute kernel</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md876">Mask out cells which are not a fit</a></li>
<li class="level1"><a href="#autotoc_md877">Sanity checks</a><ul><li class="level2"><a href="#autotoc_md878">Introduce aggressively vectorised kernel</a></li>
<li class="level2"><a href="#autotoc_md879">Fused compute kernels</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This page discusses how ExaHyPE supports SIMT and SIMD compute kernels. ExaHyPE uses GPUs in a classic <em><b>offloading</b></em>, i.e. GPUs as accelerators. This means that it takes particular tasks, ships them to the GPU and then ships them back. This happens under the hood, and neither does data reside on the accelerator permanently nor is the accelerator used all the time.</p>
<p>The whole approach assumes that there are computations (cell/patch updates) which can be done without any effect on global variables. It works if and only if we can ship a task to the GPU, and then get the solution data for this task back and no other global variabled changes. We furthermore assume that the computations that fit onto the GPU have no state. They can use some global, static variables, but they cannot access the solver's state which can change over time. We rely on code parts which <em>have no side effects and do not depend on the solver state</em> (minus global variables).</p>
<p>The same argument holds for aggressive vectorisation: Vectorisation works best if the computations on a patch do not have any side effects. Basically, ExaHyPE assumes that GPU's SIMT and CPU's SIMD are two realisations of the same pattern.</p>
<p>Working without side-effects might not work for all patches: There are always patches which evaluate and analyse some global data, or build up global data structures. In this case, ExaHyPE only offloads the remaining, simple patches to the GPU. That is, having a solver that supports patches/cells without side effects does not mean that all cells have to be side effect-free.</p>
<p>Before you dive into this technical description of how GPU offloading (and very aggressive vectorisation) work, it makes sense to read through the <a class="el" href="../../d0/d35/tutorials_exahype_gpu.html">tutorial on GPU offloading</a>. <br  />
</p>
<h1><a class="anchor" id="autotoc_md872"></a>
Compile with GPU support</h1>
<p>Configure ExaHyPE with the argument <code>--with-gpu=xxx</code> and select an appropriate GPU programming model. Rebuild the whole Peano core. This includes the ExaHyPE libraries.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000066">Todo</a></b></dt><dd><p class="startdd">More details on teh maturity and working of coce </p>
<p class="enddd">Discussion how to introduce your own GPU-specific kernels</p>
</dd></dl>
<h1><a class="anchor" id="autotoc_md873"></a>
Enable stateless compute kernels</h1>
<p>The Finite Volume enclave solvers for example all support GPUs, but the versions without enclave tasking do not support them. The solver documentation should clarify which one to select. For most of these GPU-enabled solvers, it is sufficient to pass an additional flag</p>
<div class="fragment"><div class="line">pde_terms_without_state=True</div>
</div><!-- fragment --><p>for the FV variants, e.g.) that tells the solver that we have <a class="el" href="../../da/db8/namespacePDE.html">PDE</a> terms which have no side effect which also do not need the solver object. Consult the documentation of the respective solvers. Examples are</p>
<ul>
<li>exahype2.solvers.fv.rusanov.GlobalAdaptiveTimeStepWithEnclaveTasking</li>
<li>yet to be added</li>
</ul>
<h2><a class="anchor" id="autotoc_md874"></a>
Provide the additional PDE terms without state</h2>
<p>To faciliate the offloading, we have to create alternative versions of our <a class="el" href="../../da/db8/namespacePDE.html">PDE</a> term functions that can work independent of the solver object (and in return cannot modify it). Depending on which terms we have, we'll need stateless versions of the flux, the non-conservative product and the source term. We'll always needs the eigenvalue function. Per function, keep the original one and add a second one which is</p>
<ul>
<li>static;</li>
<li>accepts an additional flag of type <code>Offloadable</code>. This is the last argument, i.e. a static version of a function has exactly the same arguments as the non-static, default variant but then has one more argument. The last argument is solely there to be able to distinguish the static version from the normal one, as C++ cannot overload w.r.t. static vs. not static. <code>Offloadable</code> is automatically defined in the abstract base class which 's Python API generates.</li>
<li>is embedded into <div class="fragment"><div class="line"><span class="preprocessor">#if defined(OpenMPGPUOffloading) </span></div>
<div class="line"><span class="preprocessor">#pragma omp declare target</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> my new static function variants <div class="fragment"><div class="line"><span class="preprocessor">#if defined(OpenMPGPUOffloading) </span></div>
<div class="line"><span class="preprocessor">#pragma omp end declare target</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> Though you can leave these annotations away if you use SYCL only.</li>
</ul>
<p>Most ExaHyPE solvers allow you to insert the realisation of a routine directly from the Python code. In this case, the call ends up the AbstractMySolver class. Most classes call the corresponding routine set_implementation(). If you use this one, the code generator usually does not distinguish the two callback flavours and uses the same code snippet for the normal as well as the vectorised version. However, it is likely that the files end up in the cpp file of the abstract super class. That is, the compiler will not be able to inline anything. If your compiler struggles with the inlining, you might be forced either</p>
<ul>
<li>to dive into linker-time optimisation - Intel, for example, did allow you to run interprocedural optimisation (ipo) on bundles of object files; or</li>
<li>to switch to a manual implementation and to move the GPU routines into the headers.</li>
</ul>
<h2><a class="anchor" id="autotoc_md875"></a>
Alter compute kernel</h2>
<p>ExaHyPE solvers which support GPUs/stateless operators typically host three different compute kernels. These kernels are plain C++ function calls, i.e. strings, on the Python level.</p>
<ul>
<li><code>self._compute_kernel_call</code> is a C++ function call for the normal task. This guy is called whenever you hit an octant, i.e. Finite Volume patch or a DG cell. It calls the virtual flux, eigenvalue, ... functions on the solver object.</li>
<li><code>self._fused_compute_kernel_call_cpu</code> is a C++ function call that ExaHyPE uses whenever it encounters a set of octants in the tree which can be processed embarrassingly parallel as they all invoke the same <a class="el" href="../../da/db8/namespacePDE.html">PDE</a> and none of them alters the state of the underlying solver object. So the compute kernels identified by this string can call the static flux and eigenvalue instead of the virtual function.</li>
<li><code>self._fused_compute_kernel_call_gpu</code> is the equivalent to <code>_fused_compute_kernel_call_cpu</code> which the code uses when it decides to offload a bunch of cells to an accelerator.</li>
</ul>
<p>By default, these variants should point to reasonable variants once you switch on stateless operators and the variants are typically constructed in a way that they distinguish the various backends we support. That is, they yield a string of the form</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if defined(GPUOffloadingSYCL)</span></div>
<div class="line">exahype::fv::rusanov::sycl::timeStepWithRusanovPatchwiseStateless(...)</div>
<div class="line"><span class="preprocessor">#else if defined(GPUOffloadingOMP)</span></div>
<div class="line">...</div>
<div class="line">#endif</div>
</div><!-- fragment --><p>which automatically picks a working default backend depending on your configuration.</p>
<p>While this gives you a working version quickly, you might want to switch to a tailored variant for your particular solver. This can be done by changing the actual solver kernel:</p>
<div class="fragment"><div class="line">mysolver._fused_compute_kernel_call_gpu = <a class="code hl_namespace" href="../../dd/d6c/namespaceexahype2.html">exahype2</a>.kerneldsl.api.compile( .... )</div>
<div class="ttc" id="anamespaceexahype2_html"><div class="ttname"><a href="../../dd/d6c/namespaceexahype2.html">exahype2</a></div><div class="ttdoc">For the generic kernels that I use here most of the time.</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d65/CellAccess_8h_source.html#l00013">CellAccess.h:13</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md876"></a>
Mask out cells which are not a fit</h1>
<p>If only some patches/cells can be offloaded to the GPU, then you can redefine the routine</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> patchCanUseStatelessPDETerms( </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="../../d7/d26/structtarch_1_1la_1_1Vector.html">tarch::la::Vector&lt;Dimensions,double&gt;</a>&amp;  patchCentre, </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="../../d7/d26/structtarch_1_1la_1_1Vector.html">tarch::la::Vector&lt;Dimensions,double&gt;</a>&amp; patchH, <span class="keywordtype">double</span> t, <span class="keywordtype">double</span> dt </div>
<div class="line">) <span class="keyword">const</span>;</div>
<div class="ttc" id="astructtarch_1_1la_1_1Vector_html"><div class="ttname"><a href="../../d7/d26/structtarch_1_1la_1_1Vector.html">tarch::la::Vector</a></div><div class="ttdoc">Simple vector class.</div><div class="ttdef"><b>Definition</b> <a href="../../d6/dbe/Vector_8h_source.html#l00084">Vector.h:84</a></div></div>
</div><!-- fragment --><p>in your solver. By default, this routine returns <code>true</code> always. Here's the clue: This is a normal function, i.e. you can use the solver's state and make the result depend on this one.</p>
<p>patchCanUseStatelessPDETerms() yields, by default, true. So all compute kernels end up on the GPU if they are embedded into enclave tasks. You migth want to alter this, and keep some kernels on the host.</p>
<h1><a class="anchor" id="autotoc_md877"></a>
Sanity checks</h1>
<p>The sections below discuss what you should see in the code.</p>
<h2><a class="anchor" id="autotoc_md878"></a>
Introduce aggressively vectorised kernel</h2>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000067">Todo</a></b></dt><dd>This will change completely as we switch to xDSL. Notably, we will not support multiple target GPUs in one source code anymore.</dd></dl>
<p>Once you have a GPU-ready solver, it makes sense to doublecheck quickly if the solver really dispatches the correct compute kernels. For this, we first study the generated task. Stateless routines are also very useful on the CPU, as we can aggressively vectorise over them. Therefore, the task should look similar to</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> benchmarks::exahype2::ccz4::tasks::CCZ4FVEnclaveTask::applyKernelToCell(...) {</div>
<div class="line">  ...</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">if</span> (repositories::instanceOfCCZ4FV.patchCanUseStatelessPDETerms(</div>
<div class="line">      marker.x(),</div>
<div class="line">      marker.h(),</div>
<div class="line">      t,</div>
<div class="line">      dt</div>
<div class="line">  )) {</div>
<div class="line">    ::exahype2::fv::rusanov::timeStepWithRusanovPatchwiseHeapStateless&lt;</div>
<div class="line">      ...</div>
<div class="line">     &gt;(patchData);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">     ::exahype2::fv::rusanov::timeStepWithRusanovPatchwiseHeapFunctors&lt;</div>
<div class="line">      ...</div>
<div class="line">     &gt;(patchData,</div>
<div class="line">     ...</div>
<div class="line">     );</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The kernels might look completely different, but the principle is clear: Whenever we hit a cell, we check if patchCanUseStatelessPDETerms() holds. If this is not the case, we use the default version. However, if it holds, then we invoke the specialised version which assumes that there is a version with static (stateless) calls.</p>
<h2><a class="anchor" id="autotoc_md879"></a>
Fused compute kernels</h2>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000068">Todo</a></b></dt><dd>This will change completely as we switch to xDSL. Notably, we will not support multiple target GPUs in one source code anymore.</dd></dl>
<p>Scroll further down until you see the fuse() routine. This one is again very simple to digest:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> benchmarks::exahype2::ccz4::tasks::CCZ4FVEnclaveTask::fuse(<span class="keyword">const</span> std::list&lt;Task*&gt;&amp; otherTasks, <span class="keywordtype">int</span> <a class="code hl_variable" href="../../df/d1e/exahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h.html#ac985d7625a1635142e5c915a145a4134">targetDevice</a>) {</div>
<div class="line">  ...</div>
<div class="line">  #<span class="keywordflow">if</span> defined(GPUOffloadingOMP)</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_variable" href="../../df/d1e/exahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h.html#ac985d7625a1635142e5c915a145a4134">targetDevice</a> &gt;= 0) {</div>
<div class="line">      foundOffloadingBranch = <span class="keyword">true</span>;</div>
<div class="line">      ::exahype2::fv::rusanov::omp::timeStepWithRusanovPatchwiseHeapStateless&lt;</div>
<div class="line">      ...</div>
<div class="line">      &gt;(<a class="code hl_variable" href="../../df/d1e/exahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h.html#ac985d7625a1635142e5c915a145a4134">targetDevice</a>, patchData);</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">  #endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">  #if defined(GPUOffloadingSYCL)</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_variable" href="../../df/d1e/exahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h.html#ac985d7625a1635142e5c915a145a4134">targetDevice</a> &gt;= 0 or <a class="code hl_variable" href="../../df/d1e/exahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h.html#ac985d7625a1635142e5c915a145a4134">targetDevice</a> == Host) {</div>
<div class="line">      foundOffloadingBranch = <span class="keyword">true</span>;</div>
<div class="line">      ::exahype2::fv::rusanov::sycl::timeStepWithRusanovPatchwiseHeapStateless&lt;</div>
<div class="line">        ...</div>
<div class="line">      &gt;(<a class="code hl_variable" href="../../df/d1e/exahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h.html#ac985d7625a1635142e5c915a145a4134">targetDevice</a>, patchData);</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">  #endif</span></div>
<div class="ttc" id="aexahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h_html_ac985d7625a1635142e5c915a145a4134"><div class="ttname"><a href="../../df/d1e/exahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h.html#ac985d7625a1635142e5c915a145a4134">targetDevice</a></div><div class="ttdeci">targetDevice</div><div class="ttdef"><b>Definition</b> <a href="../../df/d1e/exahype2_2solvers_2fv_2godunov_2kernels_2cuda_2Loop_8template_8h_source.html#l00176">Loop.template.h:176</a></div></div>
</div><!-- fragment --><p>We see here, that SYCL can run on both the host and the device, whereas we pick the OpenMP version if and only if we have picked a valid device.</p>
<p>If this call logic makes no sense, most solvers have attributes such as </p><pre class="fragment">    self._fused_compute_kernel_call_cpu
    self._fused_compute_kernel_call_gpu
</pre><p> to switch to the modified kernel realisation variant. Typically, there are factory mechanisms to alter those guys:</p>
<div class="fragment"><div class="line">my_solver._fused_compute_kernel_call_gpu  = <a class="code hl_namespace" href="../../dd/d6c/namespaceexahype2.html">exahype2</a>.<a class="code hl_namespace" href="../../d0/d4e/namespaceexahype2_1_1solvers.html">solvers</a>.<a class="code hl_namespace" href="../../de/d1e/namespaceexahype2_1_1solvers_1_1fv.html">fv</a>.<a class="code hl_namespace" href="../../df/d39/namespaceexahype2_1_1solvers_1_1fv_1_1rusanov.html">rusanov</a>.kernels.create_compute_Riemann_kernel_for_Rusanov(</div>
<div class="line">  my_solver._flux_implementation, </div>
<div class="line">  my_solver._ncp_implementation, </div>
<div class="line">  my_solver._source_term_implementation, </div>
<div class="line">  compute_max_eigenvalue_of_next_time_step=True, </div>
<div class="line">  solver_variant         = <a class="code hl_namespace" href="../../dd/d6c/namespaceexahype2.html">exahype2</a>.<a class="code hl_namespace" href="../../d0/d4e/namespaceexahype2_1_1solvers.html">solvers</a>.<a class="code hl_namespace" href="../../de/d1e/namespaceexahype2_1_1solvers_1_1fv.html">fv</a>.<a class="code hl_namespace" href="../../df/d39/namespaceexahype2_1_1solvers_1_1fv_1_1rusanov.html">rusanov</a>.kernels.SolverVariant.Accelerator,</div>
<div class="line">  kernel_variant         = <a class="code hl_namespace" href="../../dd/d6c/namespaceexahype2.html">exahype2</a>.<a class="code hl_namespace" href="../../d0/d4e/namespaceexahype2_1_1solvers.html">solvers</a>.<a class="code hl_namespace" href="../../de/d1e/namespaceexahype2_1_1solvers_1_1fv.html">fv</a>.<a class="code hl_namespace" href="../../df/d39/namespaceexahype2_1_1solvers_1_1fv_1_1rusanov.html">rusanov</a>.kernels.KernelVariant.GenericAoS</div>
<div class="line">)</div>
<div class="ttc" id="anamespaceexahype2_1_1solvers_1_1fv_1_1rusanov_html"><div class="ttname"><a href="../../df/d39/namespaceexahype2_1_1solvers_1_1fv_1_1rusanov.html">exahype2.solvers.fv.rusanov</a></div></div>
<div class="ttc" id="anamespaceexahype2_1_1solvers_1_1fv_html"><div class="ttname"><a href="../../de/d1e/namespaceexahype2_1_1solvers_1_1fv.html">exahype2.solvers.fv</a></div><div class="ttdef"><b>Definition</b> <a href="../../d6/d91/python_2exahype2_2solvers_2fv_2____init_____8py_source.html#l00001">__init__.py:1</a></div></div>
<div class="ttc" id="anamespaceexahype2_1_1solvers_html"><div class="ttname"><a href="../../d0/d4e/namespaceexahype2_1_1solvers.html">exahype2.solvers</a></div><div class="ttdef"><b>Definition</b> <a href="../../d8/d91/python_2exahype2_2solvers_2____init_____8py_source.html#l00001">__init__.py:1</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d3/d82/page_exahype2_home.html">ExaHyPE 2</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:04 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
