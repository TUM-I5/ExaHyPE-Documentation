<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/d00/page_peano_domain_decomposition.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Domain decomposition</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1021">Domain decomposition within a (typical) Peano application</a><ul><li class="level2"><a href="#autotoc_md1022">Observers and action sets</a></li>
<li class="level2"><a href="#autotoc_md1023">Lifecycle of action sets</a></li>
<li class="level2"><a href="#autotoc_md1024">Data exchange</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1025">Decomposition constraints</a><ul><li class="level2"><a href="#autotoc_md1026">Examples</a></li>
<li class="level2"><a href="#autotoc_md1027">Rationale</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1028">Data flow patterns</a><ul><li class="level2"><a href="#autotoc_md1029">Horizontal data flow</a></li>
<li class="level2"><a href="#autotoc_md1030">Asynchronous vertical data flow</a></li>
<li class="level2"><a href="#autotoc_md1031">Synchronous vertical data flow</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1032">Splits</a><ul><li class="level2"><a href="#autotoc_md1033">User data throughout splits</a></li>
<li class="level2"><a href="#autotoc_md1034">Data ownership throughout splits</a></li>
<li class="level2"><a href="#autotoc_md1035">Observation and best practices</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1036">Joins</a><ul><li class="level2"><a href="#autotoc_md1037">Temporal ordering throughout joins with SpacetreeSet</a></li>
<li class="level2"><a href="#autotoc_md1038">Data ownership throughout joins</a></li>
<li class="level2"><a href="#autotoc_md1039">Grid data streaming throughout joins</a></li>
<li class="level2"><a href="#autotoc_md1040">User data streaming throughout joins</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1041">Implementation</a><ul><li class="level2"><a href="#autotoc_md1042">Using replication information</a></li>
<li class="level2"><a href="#autotoc_md1043">Distributed memory (MPI) realisation</a></li>
<li class="level2"><a href="#autotoc_md1044">Shared memory between different trees (instances of action sets) and different action sets on one rank</a></li>
<li class="level2"><a href="#autotoc_md1045">Design patterns for (MPI) global variables between action sets</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><div style="background-color: #ccf ; padding: 10px; border: 1px solid green;"> This page will frequently refer to action sets and their order. It therefore is reasonable to study <a class="el" href="../../da/d1b/peano_action_sets.html">the description of action sets</a> first. </div><div class="image">
<img src="../../domain-decomposition.png" alt=""/>
</div>
<p>Peano starts from spacetrees and thinks in whole trees and only supports two types of decomposition operations: a split and a join. At the same time, it does not distinguish shared memory and distributed memory parallelisation. It only thinks in terms of trees. The trees and their traversal can either be deployed to ranks or threads or combinations of the two.</p>
<p>This statement is only weakened once you work with 's task interface. If trees issue tasks, then these tasks team up with the tasks handling the individual spacetrees. Your task graph starts to contain a mixture of tree tasks and user-defined tasks. This section discusses solely the tree decomposition aspect within Peano, i.e. ignores that there might be tasks as well.</p>
<div style="background-color: #cfc ; padding: 10px; border: 1px solid green;"> Each subtree is completely independent: If Peano cuts a tree into chunks, these trees do not share any data anymore, no matter whether they are deployed onto separate ranks or separate treads or a mixture of those. We work with a multiscale, non-overlapping domain decomposition. </div><h1><a class="anchor" id="autotoc_md1021"></a>
Domain decomposition within a (typical) Peano application</h1>
<p>A tree in Peano is split along the Peano space-filling curve. This implies that the decomposition on each mesh level is a non-overlapping decomposition where each cell is assigned to exactly one chunk.</p>
<div class="image">
<img src="../../replicated-boundary-data.png" alt=""/>
</div>
<p>The illustration above makes this point: The blue and the red tree own a part of the overall domain. They do not share any cells, but they have a common boundary of four edges.</p>
<p>Data on these edges is replicated, i.e. the four faces exist twice: once on the red and on the blue tree. Also the two marked vertices exist twice.</p>
<p>Peano still works with proper trees and will actually let the red tree store parts of the blue partition as well and vice versa. How this is done is hidden from the user. Effectively, you know that each rank will somehow run through a part of the global domain. Some synchronisation and consistency rules remain in place:</p>
<ul>
<li>Red will definitely skip all blue cells even if it should hold them.</li>
<li>Both trees will preserve the exactly same order for all shared data. If red touches the green vertex prior to the red one, then the blue partition will also process the vertices in the same order.</li>
<li>After each mesh traversal, the two trees will exchange their data (although there are two other data exchange schemes as well).</li>
<li>Both trees will trigger the related additional merge actions as described below.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1022"></a>
Observers and action sets</h2>
<p>If you run Peano 4, you buy into a SPMD paradigm, i.e. every single rank hosts one instance of Peano. Each Peano instance in return hosts multiple subspacetrees, i.e. multiscale domain partitions. When you pick a new observer with some action sets and you call traverse(), you expect that all the trees on each and every rank run through their mesh and use the same observer, i.e. deploy events to the same action sets.</p>
<p>It is the user's responsibility to ensure that the ranks do coordinate with each other. That is, the user has to ensure that whenever you run a certain type of grid sweep on one rank, then the other ranks run this sweep as well. I provide remarks on this at the end of the page. Most users will never ever see this part - notably not if they use high-level toolkits built on top of Peano such as ExaHyPE or Swift 2. The main codes produced by these high-level extensions automatically guarantee that all ranks do exactly the same.</p>
<h2><a class="anchor" id="autotoc_md1023"></a>
Lifecycle of action sets</h2>
<p>Each action set (instance of the class) is created once per tree. In addition, a prototype action set does exist.</p>
<p>In the baseline version, only one instance of an action set does exist per rank. For this action set, we call prepareTraversal(). Once this routine has terminated, we create N clones of the action set object if we host N subtrees. As ranks can host different numbers of subtrees, the number of clones differs per rank.</p>
<p>As each subtree is completely independent of all other subtrees, beginTraversal() and endTraversal() are called on the clone, i.e. multiple times. If vertices or faces sit exactly at the interface of subdomains, they their touchVertexFirstTime() is called multiple times, i.e. once per instance of this vertex. touchVertexLastTime() and the face events follow analogously.</p>
<p>After all trees on a rank have finished their traversal, i.e. all the endTraversal() calls have returned, the clones of the action sets are destroyed, and we all unprepareTraversal() one final time on the vanilla/baseline instance of the action set.</p>
<h2><a class="anchor" id="autotoc_md1024"></a>
Data exchange</h2>
<p>After the traversal has terminated, Peano is responsible to exchange all data. This is completely hidden. At one point prior to the next usage of any data, Peano will issue additional merge routines, so users can define domain-specific logic:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event   </th><th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone">Dependencies    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">receiveAndMergeVertex   </td><td class="markdownTableBodyNone">If a vertex exists on N different trees, this routine is called N-1 times per tree, i.e. in total N(N-1) times: Each local vertex is presented its N-1 counterparts per traversal.   </td><td class="markdownTableBodyNone">This routine precedes touchVertexFirstTime().    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">receiveAndMergeFace   </td><td class="markdownTableBodyNone">If a face exists on two trees, this routine is called once per tree, i.e. twice in total: Each local face is presented its counterpart per traversal.   </td><td class="markdownTableBodyNone">This routine precedes touchVertexFaceTime().    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">touchVertexLastTime   </td><td class="markdownTableBodyNone">Afer this routine has terminated, each tree takes (for all vertices along a boundary) the latest version and shares it with all other replicas. It sends it out. The sent data will be presented to the merge routine on the counterpart at an arbitrary time in the next mesh sweep.   </td><td class="markdownTableBodyNone">This routine precedes receiveAndMergeVertex of the next mesh sweep.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">touchFaceLastTime   </td><td class="markdownTableBodyNone">Afer this routine has terminated, each tree takes (for all faces along a boundary) the latest version and shares it with the other tree holding a copy of this face. It sends it out. The sent data will be presented to the merge routine on the counterpart at an arbitrary time in the next mesh sweep.   </td><td class="markdownTableBodyNone">This routine precedes receiveAndMergeFace of the next mesh sweep.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">prepareTraversal   </td><td class="markdownTableBodyNone">Is called once per rank before we create the actual action sets.   </td><td class="markdownTableBodyNone">Precedes the beginTraversal() calls which are called once per subtree.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unprepareTraversal   </td><td class="markdownTableBodyNone">Is called ocne per rank after the rank-local traversals have all terminated.   </td><td class="markdownTableBodyNone">Follows the last endTraversal() call.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md1025"></a>
Decomposition constraints</h1>
<p>Before we discuss any algorithms that Peano employs, it is important to state that Peano always commits to two fundamental constraints:</p>
<ol type="1">
<li><b>Topology constraint</b> Also Peano's coarser cells are uniquely assigned to one tree. Between the ranks, we have a tree topology again. That is, a splitting of a tree is always realised such that there's a unique master-worker topology.</li>
<li><b>Grid regularity constraint</b> Peano implements one further constraint which refers to the handling of AMR. A cell can be forked onto another rank if and only if all of its vertices are persistent.</li>
</ol>
<p>Both constraints are implemented via <a class="el" href="../../df/df6/classpeano4_1_1grid_1_1Spacetree.html#afe9730dc3126f08ec31186187c7a6b54" title="Can a cell be split (deployed to another rank)">peano4::grid::Spacetree::isCellSplitCandidate()</a>. Details on this as well as further rationale (the ones below refer to the constraints only) can also be found in <a class="el" href="../../df/df6/classpeano4_1_1grid_1_1Spacetree.html#a85cba869defa7a1b32338f35f373de8c" title="Realise the splits and joins.">peano4::grid::Spacetree::splitOrJoinCellBottomUp()</a> and <a class="el" href="../../df/df6/classpeano4_1_1grid_1_1Spacetree.html#af60654c13930f6d542f840414fc56b0e" title="Split cell in a top down fashion.">peano4::grid::Spacetree::splitCellTopDown()</a>. As we have to accommodate these two constraints, splits typically never are "exact", i.e. you might ask for 100 cells cells to be split off, but Peano will eventually only split off roughly 100 cells. It will try to stay close to 100, but the constraints have a higher priority than your request.</p>
<div style="background-color: #cfc ; padding: 10px; border: 1px solid green;"> Load balancing schemes make <em><b>recommendations</b></em> to Peano how to split up the mesh. However, a split() call is never strict, i.e. Peano might decide to ignore it or to implement it only partially. This happens whenever the mesh changes on-the-fly or a constraint might be violated if we followed the split instruction strictly. </div><h2><a class="anchor" id="autotoc_md1026"></a>
Examples</h2>
<div class="image">
<img src="../../tree-topology.png" alt=""/>
</div>
<p>Some examples in the figure above sketch the implications of the topology constraint: In the left example, the yellow tree has split up into yellow and green. The green tree has further split into green and red. The code usually tries to keep whole trees, i.e. children and parents, within one tree. In the left example, it would be natural to make the very right green cell on the first child level a red one, too. This way, a whole tree would reside in red. However, if we made this single cell red, then red would become a child of yellow, i.e. we would change the rank topology. Peano never does so. In the right example conversely, I've asked the yellow tree to split into yellow, green and red in one rush. This time, the right level 1 cell becomes red already.</p>
<p>Both examples show that a split of one tree into further trees never results in the fact that the original tree becomes empty. Otherwise, we would again change the tree topology upon the ranks.</p>
<div class="image">
<img src="../../regularity-constraint.png" alt=""/>
</div>
<p>Im the mesh above, a rank can fork off the green cell. In the sketch, the green cell is the root of a tree with two more levels. A fork of the green cell consequently would fork off a whole tree (see topology constraint above). However, we are forbidden to fork off the red cell and its nine children. We could fork off the blue cell, but the red cell is hanging and therefore not a split candidate. It is, in general, difficult to identify such critical situations: The green cell with all of its children can be identified in a top-down sweep, but then we run risk that the green cell plus its children sum up to more cells than we actually wanna split. Therefore, we provide two split variants (cmp <a class="el" href="../../df/df6/classpeano4_1_1grid_1_1Spacetree.html#a85cba869defa7a1b32338f35f373de8c" title="Realise the splits and joins.">peano4::grid::Spacetree::splitOrJoinCellBottomUp()</a> and <a class="el" href="../../df/df6/classpeano4_1_1grid_1_1Spacetree.html#af60654c13930f6d542f840414fc56b0e" title="Split cell in a top down fashion.">peano4::grid::Spacetree::splitCellTopDown()</a>) and leave it to the user to decide whether they want to try to meet the number of cells split off or try to maximise the probability that whole trees are split off.</p>
<h2><a class="anchor" id="autotoc_md1027"></a>
Rationale</h2>
<p>We want to work with a proper master-worker topology such that we have well defined relations where a tree has to send data to if data has to go to coarser levels. The topology also allows us to run reductions along trees, or to clarify who is allowed to split and who is not. The topology furthermore allows us to veto erase commands if they would erase whole subdomains. Most importantly, a clear master-worker topology makes joins more straightforward (they are always nasty), as we don't have to deal with 1:n data flows when we join a partition.</p>
<p>The regularity constraint is important as we have to update a vertex state if a mesh refines or erases dynamically. In this case, a rank might trigger an erase and a child who holds the neighbouring refined cell has to implement this erase as well. If the erase now suddenly creates a hanging node on the coarsest level, this hanging node does not carry any adjency information anymore. Adjacency now has to be propagated through from even coarser level, which is difficult in a distributed data environment. By defining that all the coarsest octants on a rank have to have exclusively persistent vertices, we avoid the complications that adjacency information might be outdated. We also ensure that we handle all data consistency through (multilevel) exchange of vertex data with neighbours. No data has to be propagated between levels just to get the vertex data right.</p>
<h1><a class="anchor" id="autotoc_md1028"></a>
Data flow patterns</h1>
<p>With these two constraints in place, we can discuss Peano's data flow: The code relies on a multiscale non-overlapping domain decomposition. Within the trees, we distinguish three different types of parallel data flow:</p>
<ul>
<li><b>Horizontal data exchange</b> is exchange between two cells of one level along their boundary.</li>
<li><b>Synchronous vertical data exchange</b> is exchange between trees where one resolution meets the other. Vertical data exchange is synchronous if a coarse mesh passes information down the grid hierarchy in one sweep and/or receives information from finer meshes and immediately, i.e. in the same sweep, continues to process these data. Synchronous vertical data exchange is used to stream data from one rank to the other if we fork.</li>
<li><b>Asynchronous vertical data exchange</b> is exchange between parent-child trees where the coarser parent sends data to its child, but the data is used there on the child's coarsest level in the subsequent grid traversal. Along the same lines, we speak of asynchronous vertical data exchange if the coarest level on a child sends data one level up, but these data are not used on the next coarser level which is owned by the parent before the next mesh traversal.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1029"></a>
Horizontal data flow</h2>
<p>Peano uses a non-overlapping domain decomposition. Therefore, ie shares/exchanges faces and vertices between different trees where these grid entities have adjacent octants on the same level which are owned by different trees. However, it never shares cells of one level. I explain the code's data exchange pattern with vertices. Yet, the same pattern holds for faces, too.</p>
<p>After a code has read/written a vertex for the very last time throughout a traversal, it sends a copy of this vertex away. In-between two iterations, all trees exchange their data. That is, in the next iteration any sent out data is available on the destination rank and can be merged into the local data structures. This merge happens on the destination prior to any other operation.</p>
<div class="image">
<img src="../../boundary-data-flow.png" alt=""/>
</div>
<p>Peano consequently realises a data exchange that is similar to Jacobi smoothers: Whatever you do on one tree won't be visible on the other trees in this very tree traversal. Prior to the next tree sweep, this information however becomes available there.</p>
<h2><a class="anchor" id="autotoc_md1030"></a>
Asynchronous vertical data flow</h2>
<p>This yet has to be written.</p>
<h2><a class="anchor" id="autotoc_md1031"></a>
Synchronous vertical data flow</h2>
<p>This yet has to be written.</p>
<h1><a class="anchor" id="autotoc_md1032"></a>
Splits</h1>
<p>Splits are triggered via <a class="el" href="../../da/d58/classpeano4_1_1parallel_1_1SpacetreeSet.html#a4c99275a5fd270dce1999818063bd802" title="Split a local tree.">peano4::parallel::SpacetreeSet::split()</a>. Whenever you split a tree, Peano creates the new trees (either as threads on the local node or remotely via MPI). Each new tree receives a whole copy of the original tree. This includes both the core tree data and the user data. Once the tree is replicated, the individual trees start to coarsen. If they are not responsible for tree parts, they successively remove this part. After one or two iterations, each rank thus really works only on local tree. Due to this approach, splits require significant memory temporarily. It thus might be convenient not to split a tree too often in one rush.</p>
<p>Peano uses information from the actively used data to decide which data to replicate. If you have cell and vertex and face data but you use some of these data only in some substeps of you algorithm, please ensure that those steps that trigger the domain decomposition and those that run immediately after this do use all data types. Otherwise, Peano can't know what data is to be replicated when it splits trees.</p>
<p>If you split a tree, the original tree, i.e. the source of the data, makes the new tree run through two states: split triggered and splitting.</p>
<div class="image">
<img src="../../SpacetreeSet_split.png" alt=""/>
</div>
<p>In a usual run, Peano's trees do exchange data in a way similar to the Jacobi smoothing: Each tree traverses its domain and sends out all boundary data. I call this horizontal communication as it is data exchange between non-overlapping domains which can be arranged on one grid level. In the next iteration, the data from neighbours has arrived and can be merged in. We obtain a criss-cross communication pattern (blue steps) where an iteration feeds into the neighbour's iteration n+1.</p>
<p>While a new id is booked by one tree if a split is triggered, this new tree does not yet physically exist. The original (source) tree keeps the complete ownership of all data, i.e. it does all refines and coarses and also creates all events. However, it already enters the new, yet to be created, tree's indices into all adjacency lists with are consequently sent out to the other ranks. This is the yellow step above. After the grid sweep, we mark the new tree id as splitting. At this point, all neighbours continue to send to the original tree, as they are not yet aware of any domain partition updates.</p>
<p>While an id is associated with splitting (orange), we know that all the other trees around start to send data to the new tree that is yet to be created: they receive the information about the updated adjacency and can send out their stuff to the new tree. Which does not exist yet (grey).</p>
<p>So the splitting rank (orange) traverses its domain and invokes all events. It has the semantic ownership. It merges in all boundary data from neighbours, but is does not send out the boundary data (anymore). After the splitting tree traversal has terminated, we establish the new tree by duplicating all the local data. This includes the user data, too.</p>
<p>The new tree (light green) subsequently is traversed once as empty tree. That is, all data travel over the stacks, but no events are invoked and no communication is happening. The purpose of this empty traversal is to get all data inot the right order.</p>
<p>Once the empty traversal has terminated, we run over the new tree again. This time, we label it as new (dark green). While we still do not invoke any event, we now do send out data. This is the sole purpose of the new traversal.</p>
<p>It is not guaranteed that the splits are all successful. See the routine <a class="el" href="../../df/df6/classpeano4_1_1grid_1_1Spacetree.html#afe9730dc3126f08ec31186187c7a6b54" title="Can a cell be split (deployed to another rank)">peano4::grid::Spacetree::isCellSplitCandidate()</a> which identifies cells that can be split. Effectively, you might call split and not get any tree decomposition at all.</p>
<p>With the information of the data flow above, any splits actually has to be realised over two grid sweeps which internally decompose into substeps:</p>
<ol type="1">
<li>The user asks a tree to split. From hereon, we have a master with some neighbours and a worker. The latter does not physically exist yet.</li>
<li>The master runs through its domain and tells all neighbouring ranks that the new tree will drop in in the future. At this time, these neighbours are not yet aware of the split (the information becomes only available in the subsequent iteration), so they continue to send their stuff to the master even though it might be vertices which will, in the future, belong to the new worker. We say that that we have a <b>split-triggered</b> in this iteration.</li>
<li>In the next iteration, the master is <b>splitting</b>. It still holds the ownership of all the data, as it receives for example all neighbour data. However, in the splitting phase, the master already sends out data to the worker where new domain boundaries will arise&mdash;even though the new worker does not exist yet. The same happens to all the neighbours. They send out boundary data to this new worker that will now enter the game.</li>
<li>Once the master has terminated, the responsible rank issues a couple of postprocessing steps:<ol type="a">
<li>It clones the whole master tree. This is only the grid structure, but it is a complete clone.</li>
<li>It instantiates the new worker with this cloned data. As we clone after the master's traversal has terminated, a lot of trees have already sent data to the new worker that we just cloned. However, this worker has not yet sent out any data, so we've broken the symmetry of our data exchange. Therefore, we run through the tree once as <b>empty tree</b>. In this sweep, we do nothing. We only run once through the tree to ensure that the stack data is in the right order.</li>
<li>Immediately after that, we do a <b>new tree</b> sweep. This sweep does not invoke any user events. It however sends out the data the others expect from us.</li>
</ol>
</li>
</ol>
<div class="image">
<img src="../../split-data-flow.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md1033"></a>
User data throughout splits</h2>
<p>There is no need for the user to implement something manually, as long as the user ensures that the grid observer replicates the master tree on all new workers. The <code>SpacetreeSet</code> offers a function to do this automatically.</p>
<h2><a class="anchor" id="autotoc_md1034"></a>
Data ownership throughout splits</h2>
<p>Throughout the split traversals, the code continues to interact with the user and continues to compute, i.e. all splitting is seamlessly interwoven with standard compute mesh traversals. Throughout the whole split, the logical ownership of all data resides with the master, i.e. it is the master automaton who asks the user code what operations to invoke on the data.</p>
<h2><a class="anchor" id="autotoc_md1035"></a>
Observation and best practices</h2>
<p>As  preserves the logical topology between trees, it is reasonable to strive for as wide tree topologies as possible. Otherwise, your meshes (coarsening) are very constrained. That is, it is better to split a tree a into five parts a,b,c,d,e with b,c,d,e being children of a rather than splitting a into b,c and then b and c again.</p>
<h1><a class="anchor" id="autotoc_md1036"></a>
Joins</h1>
<p>Joins are completely hidden from the user, i.e. there's no way to actively join trees. To understand why Peano issues joins from time to time, it is important to define vetoed coarsening.</p>
<p>Peano vetos any coarsening, if removing some parts of the grid would affect a child or alter the tree topology of the ranks. If a coarsening is vetoed, Peano remembers this veto. As soon as a rank whose master is affected by a veto hosts a tree cell which is unrefined, it joins/merges this cell into the master.</p>
<p>Vetoed coarsening typically does delay any grid coarsening. You ask for a coarsened grid, and it first of all applies this coarsening to all ranks that have not decomposed further. Once these have finished their coarsening, it joins those ranks that stop further coarsening into their master. Once this is complete, it continues to coarsen. This process can continue recursively.</p>
<p>For this reason, the join of partitions in  follows a few mantraic principles:</p>
<ol type="1">
<li>We only join partitions if they do not hold refined cells. We call such partitions deteriorated (in a tree sense). If a partition holds a refined cell, it cannot be merged into its father.</li>
<li>We hide joins from the user, i.e. a user can split up a partition and thus implement load balancing, but a user is never allowed to join. Joins are always triggered by 's core internally. The policy is as follows:<ul>
<li>We join a deteriorated partition if the master resides on the same rank and if this master would like to coarsen its domain but can't do so as this coarsening would violate the tree topology (see dicussion above).</li>
<li>We join a deteriorated partition if the master resides on a different rank. The idea here is that such deteriorated partitions always induce quite some overhead.</li>
</ul>
</li>
</ol>
<p>There's technical rationale behind some items: We don't join deep trees with their master as both master and worker work with their LET, i.e. try to coarsen their respective mesh as aggressively as possible after the split. Therefore, a master does not have all grid infrastructure of a worker available. It would require some complex zipping to bring the info of two trees together. If I realise a deteriorated-trees-only policy, I don't need such zipping as (almost) all information is available on the master already.</p>
<h2><a class="anchor" id="autotoc_md1037"></a>
Temporal ordering throughout joins with SpacetreeSet</h2>
<p>Analogous to the splitting process, each join is broken up into two traversals. Throughout these traversals, the code continues to interact with the user and to compute. In the first traversal, the worker tells everybody else that it intends to join with its master. However, nothing happens. Throughout this first traversal (<b>join-triggered</b>), all the neighbours of a rank as well as its master continue to send boundary data to the tree that intends to join, as they are not yet aware of the join intention.</p>
<p>In the second traversal (<b>joining</b>), we distinguish two steps. First, the worker traverses its domain. The traversal of the master is postponed. Throughout the traversal, the worker receives incoming data and merges it with the local information. Information on the grid topology is immediately streamed to the master. Immediately means after the vertex data is read for the first time and merged. See the discussion on the grid data below. After that, the worker continues, as it still own all data (see below). When it writes data to its output stream for the very last time, the data that is adjacent with the master is written to an output stream.</p>
<p>In the second step of the second traversal, the master now runs through its grid. Before that, both grid and user data from the worker are streamed in. The master takes the streamed in mesh data right after it has read its information. Whenever it runs through a mesh entity for the very last time, it merges its local user data with the streamed-in records from the (former) worker.</p>
<h2><a class="anchor" id="autotoc_md1038"></a>
Data ownership throughout joins</h2>
<p>Throughout the split traversals, the code continues to interact with the user and continues to compute, i.e. all splitting is seamlessly interwoven with standard compute mesh traversals. Throughout the whole split, the logical ownership of all data resides with the master, i.e. it is the master automaton who asks the user code what operations to invoke on the data.</p>
<h2><a class="anchor" id="autotoc_md1039"></a>
Grid data streaming throughout joins</h2>
<p>In principle, one might assume that no streaming is required if we merge only deteriorated trees. After all, if a rank deploys some subtree to another worker, it still holds its root node locally (though flagged as remote). However, there's one delicate special case: If a tree joins its master and another neighbour changes something within the mesh, too (merges as well or splits up), then the master won't be notified of this info. The update information will reach the worker while it is joining into its master. Therefore, a merging worker does stream its vertex data immediately into the master while it joins. This streaming requires us to break up the join process into two distinct traversal phases (see primary vs. secondary remark above).</p>
<p>We don't have dedicated streams in , and there's no communication channel for joins either. However, there's by default for any piece of data a vertical exchange stream. For the joins, we hijack the vertical stacks and write the data to them. When we hand the data over to the master, we revert the order on the stack and thus effectively convert it into a stream.</p>
<h2><a class="anchor" id="autotoc_md1040"></a>
User data streaming throughout joins</h2>
<p>This section is incomplete and only partially implemented.</p>
<p>Hijack vertical stacks on grid side!</p>
<p>The realisation of joins and splits in  is totally asymmetric: For a split, all data of the splitting tree is replicated and then both the original tree and its new worker coarsen the partitions they are not responsible for. This process is realised through two additional traversals on the worker side.</p>
<p>Throughout the join, no data flows logically, as the master already has the mesh. Furthermore, only data that is actually owned by the worker is handed over to the master.</p>
<p>All the trees on one rank are held within one instance <a class="el" href="../../da/d58/classpeano4_1_1parallel_1_1SpacetreeSet.html" title="The spacetree set has to be a singleton, as it is reponsible to accept requests for new trees from re...">peano4::parallel::SpacetreeSet</a>. The set is actually a singleton, to you don't have to ensure manually that there is only one set on your rank. You can tell the spacetree set to decompose one of the local spacetrees further through its split() routine. If you invoke its traverse() routine, it will automatically ensure that all spacetrees do the same, though the actual travesal of various trees (aka subdomains) will run in parallel on multiple threads.</p>
<h1><a class="anchor" id="autotoc_md1041"></a>
Implementation</h1>
<h2><a class="anchor" id="autotoc_md1042"></a>
Using replication information</h2>
<p>Sometimes, you have to know how often a vertex or face is replicated. If you compute the global residual of a linear equation system for example, you likely would like to accumultae this information in touchVertexLastTime() or touchVertexFirstTime(). However, this means that you consider faces and vertices at domain boundaries multiple times.</p>
<p>For faces, you can simply check if a face is at the parallel boundary. For this, <a class="el" href="../../df/dd3/structpeano4_1_1datamanagement_1_1FaceMarker.html" title="Provide information about selected face.">peano4::datamanagement::FaceMarker</a> provides you the routine peano4::datamanagement::FaceMarker::isAdjacentToParallelBoundary(). For vertices, the equivalent is <a class="el" href="../../dd/dc6/structpeano4_1_1datamanagement_1_1VertexMarker.html#a84793fdaab304acefd8fac04f25cb4dd" title="Number of adjacent trees of current vertex.">peano4::datamanagement::VertexMarker::getNumberOfAdjacentTrees()</a>.</p>
<h2><a class="anchor" id="autotoc_md1043"></a>
Distributed memory (MPI) realisation</h2>
<p>A typical <a class="el" href="../../df/de6/namespacePeano4.html" title="-core-datatypes This Python script uses/invokes DaStGen2 to generate all the datatypes required by th...">Peano4</a> code distinguishes the global master (rank 0) from the workers (all other ranks). The global master hosts all the program logic, i.e. decides which steps to run in which order. There's no reason for you not to emancipate from this pattern, but it has proven of value. The main of a Peano 4 application therefore always looks similar to</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="../../d3/dfe/classtarch_1_1mpi_1_1Rank.html#a61a8765012b4b650f0c35a8ece0927bd">tarch::mpi::Rank::getInstance</a>().isGlobalMaster() ) { </div>
<div class="line">  <span class="comment">// All the program logic, i.e. all decisions here else</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> { </div>
<div class="line">  <span class="comment">// React to rank 0&#39;s decisions what to do next on all ranks</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasstarch_1_1mpi_1_1Rank_html_a61a8765012b4b650f0c35a8ece0927bd"><div class="ttname"><a href="../../d3/dfe/classtarch_1_1mpi_1_1Rank.html#a61a8765012b4b650f0c35a8ece0927bd">tarch::mpi::Rank::getInstance</a></div><div class="ttdeci">static Rank &amp; getInstance()</div><div class="ttdoc">This operation returns the singleton instance.</div><div class="ttdef"><b>Definition</b> <a href="../../d5/dcd/Rank_8cpp_source.html#l00525">Rank.cpp:525</a></div></div>
</div><!-- fragment --><p>Before we start, lets assume that each individual step (type of run through the mesh) has a unique positive number.</p>
<p>Peano handles all (multiscale) boundary data transfer and data migration within the mesh. Everything not tied to the mesh is not handled by Peano. That means there's not even a reduction of the grid statistics over MPI. We do provide reduction and broadcast features however. If you need these global data, I recommend that you realise all reductions and broadcasts in your main rather than inside of the Peano mappers or other classes. See the discussion at <a class="el" href="../../dd/d83/page_tarch_mpi.html">MPI programming</a>.</p>
<h2><a class="anchor" id="autotoc_md1044"></a>
Shared memory between different trees (instances of action sets) and different action sets on one rank</h2>
<p>This section discusses <em>shared memory programming from a domain decomposition view</em>. More general remarks on shared memory primitives and task-based programming can be found in the discussion of the <a class="el" href="../../d6/d43/namespacetarch_1_1multicore.html" title="This page describes Peano 4&#39;s multithreading namespace.">tarch::multicore</a> namespace.</p>
<p>Realising global variables shared between action sets is in principle impossible: Action sets are not persistent. They are created per traversal per tree. Furthermore, you have absolutely no knowledge how many trees any rank hosts. The only thing you know is that all trees will kind of start their traversal around the same time.</p>
<p>However, nothing stops you from having a singleton data or static data set somewhere and to let all action sets write into this one. You just have to ensure that you protected writes with semaphores.</p>
<div style="background-color: #fcc ; padding: 10px; border: 1px solid green;"> If a lot of action sets all hit the same static data concurrently, you get a lot of lock overhead. In this case I recommend that each data set creates its own local data and reduces all information from its tree there. In endTraversal(), you can then lock the static global data and commit your data there before the action set is destroyed. </div><h2><a class="anchor" id="autotoc_md1045"></a>
Design patterns for (MPI) global variables between action sets</h2>
<p>Realising global variables shared between action sets is in principle impossible: Action sets are not persistent. They are created per traversal per tree. Furthermore, you have absolutely no knowledge how many trees any rank hosts. The only thing you know is that all trees will kind of start their traversal around the same time.</p>
<p>However, there is a design pattern that you can use. It relies on the observations that (i) all the beginTraversal() events are triggered after all the global trees have synchronised. (ii) Tree 0 exists always.</p>
<ul>
<li>There are two <code>static</code> datasets per rank. This is the only valid data in-between any two grid traversals. One is the current data, one is the data from the previous sweep.</li>
<li>Every action sets builds up its local current data and commits this data to the static global dataset in endTraversal(). This local reduction has to be protected by a (rank-local) semaphore.</li>
<li>In the main routine, each rank calls a routine which reduces the static current data set to rank 0. Rank 0 then broadcasts the reduced data and each rank rolls over the reduced data into the static old data set. The current data is cleared. If you don't want to bother your main, you can use prepareTraversal() or unprepareTraversal() for this.</li>
<li>Every action set copies the old data set into its local copy.</li>
</ul>
<div style="background-color: #fcc ; padding: 10px; border: 1px solid green;"> These MPI/thread-global barriers can be very expensive and have the potential to lead to deadlocks/timeouts. Use them with care and localise their behaviour. </div> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../dd/da2/page_peano4_home.html">Peano 4</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:05 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
