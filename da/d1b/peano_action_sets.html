<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/d1b/peano_action_sets.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Action sets and events</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md1003">Overview of events</a></li>
<li class="level2"><a href="#autotoc_md1004">Example</a></li>
<li class="level2"><a href="#autotoc_md1005">Markers</a><ul><li class="level3"><a href="#autotoc_md1006">Spatial information on context</a></li>
<li class="level3"><a href="#autotoc_md1007">Multiscale data</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md1008">Sequence and parallelisation of actions</a></li>
</ul>
</ul>
</div>
<div class="textblock"><p>Peano has a variety of functions which are called during spacetree traversal events. For a full description, please see <a href="https://dl.acm.org/doi/10.1145/3319797">the original article on Peano. </a> These functions are used to inject domain behaviour into the mesh traversals:</p>
<p><a class="el" href="../../d8/d95/namespacepeano4_1_1solversteps_1_1ActionSet.html">peano4.solversteps.ActionSet</a></p>
<div class="image">
<img src="../../spacetree.png" alt=""/>
</div>
<ul>
<li>Peano splits up the spacetree into multiple trees which are distributed over the ranks and threads. This gives us <a class="el" href="../../d4/d00/page_peano_domain_decomposition.html">a multiscale, non-overlapping domain decomposition</a>.</li>
<li>Each "subtree" is traversed by an automaton which runs through the tree octant-wise. It starts from the top and runs through the local tree depth-first. You receive a sequence of touchCellFirstTime() events while the automaton goes from coarse to fine, and then the automaton also triggers touchCellLastTime() events when it backtracks from the finer level back into coarser cells.</li>
<li>Besides the cell-specific events per spacetree octant, the automaton also triggers vertex and face events when it loads (touches) a vertex or face for the first time.</li>
<li>The automaton also triggers events when it has to create hanging vertices or faces.</li>
<li>There are touchFaceLastTime() and touchVertexLastTime() counterparts.</li>
<li>The automaton triggers events when it starts and finishes a travesal.</li>
<li>If you refine or erase the mesh - I use the term erase as the natural other term "coarsen" is used by the multigrid community when they switch to a coarser resolution yet keep the data from finer levels for future operations - the automaton triggers events, too.</li>
</ul>
<p>Every event is mapped onto actions, aka function calls. Users can associate multiple action sets with each travesal, such that the automaton calls a series of actions from the individual action sets for each event.</p>
<p>Within the Python API, <a class="el" href="../../d8/d95/namespacepeano4_1_1solversteps_1_1ActionSet.html">peano4.solversteps.ActionSet</a> represents an action set. This class represents the abstraction layer that we use to model the actual event behaviour.</p>
<div class="image">
<img src="../../ActionSet.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md1003"></a>
Overview of events</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event   </th><th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone">Dependencies    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">prepareTraversal   </td><td class="markdownTableBodyNone">Static routine of an action set which is called before any action set for the particular mesh travesal is created at all.   </td><td class="markdownTableBodyNone">Precedes the construction of the action sets for the next mesh traversal. Called once per MPI rank only. Study this routine in the context of <a class="el" href="../../d4/d00/page_peano_domain_decomposition.html">data decomposition discussion</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unprepareTraversal   </td><td class="markdownTableBodyNone">Inform listeners about end of traversal on this particular subtree after all action sets have termianted and have been destructed. Static binding.   </td><td class="markdownTableBodyNone">Very last event per rank. Study this routine in the context of <a class="el" href="../../d4/d00/page_peano_domain_decomposition.html">data decomposition discussion</a>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">beginTraversal   </td><td class="markdownTableBodyNone">Inform listeners about start of traversal on this particular subtree.   </td><td class="markdownTableBodyNone">Called prior to any other event in this grid sweep.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">endTraversal   </td><td class="markdownTableBodyNone">Inform listeners about end of traversal on this particular subtree.   </td><td class="markdownTableBodyNone">Called after all other event in this grid sweep.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">createPersistentVertex   </td><td class="markdownTableBodyNone">Invoked in the context of dynamic mesh refinement when we refine. Usually used to initialise data.   </td><td class="markdownTableBodyNone">Called before anything is done with this vertex and notably prior to touchVertexFirstTime.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">destroyPersistentVertex   </td><td class="markdownTableBodyNone">Invoked in the context of dynamic mesh refinement when we erase. Might be used to wrap up data or project data that otherwise would be lost onto coarser resolution levels.   </td><td class="markdownTableBodyNone">Called after touchVertexLastTime. No further event will be triggered for this vertex. All adjacent faces have been destroed before.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">createPersistentFace   </td><td class="markdownTableBodyNone">Invoked in the context of dynamic mesh refinement when we refine. Usually used to initialise data.   </td><td class="markdownTableBodyNone">Called before anything is done with this face and notably prior to touchFaceFirstTime. All adjacent vertices have been created before.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">destroyPersistentFace   </td><td class="markdownTableBodyNone">Invoked in the context of dynamic mesh refinement when we erase. Might be used to wrap up data or project data that otherwise would be lost onto coarser resolution levels.   </td><td class="markdownTableBodyNone">Called after touchVertexLastTime. No further event will be triggered for this face.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">createCell   </td><td class="markdownTableBodyNone">Invoked in the context of dynamic mesh refinement when we refine. Usually used to initialise data.   </td><td class="markdownTableBodyNone">Called before anything is done with this cell and notably prior to touchCellFirstTime. All adjacent faces and vertices have been created before.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">destroyCell   </td><td class="markdownTableBodyNone">Invoked in the context of dynamic mesh refinement when we erase. Might be used to wrap up data or project data that otherwise would be lost onto coarser resolution levels.   </td><td class="markdownTableBodyNone">Called after touchCellLastTime. No further event will be triggered for this cell. Precedes the destruction of the adjacent faces and vertices.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">createHangingVertex   </td><td class="markdownTableBodyNone">Invoked in the context of adaptive meshes. Hanging vertices are not persistent aka stored in-between two mesh traversals. Actually, the traversal automaton might create them multiple times, i.e. up to \( 2^d-1 \) times throughout the traversal if it wants. Used to project data from the next coarser level onto the hanging entity.   </td><td class="markdownTableBodyNone">Called before any event for an adjacent face or cell is invoked.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">destroyHangingVertex   </td><td class="markdownTableBodyNone">Invoked in the context of adaptive meshes. Hanging vertices are not persistent aka stored in-between two mesh traversals and hence are destroyed for every creation encountered per mesh sweep.   </td><td class="markdownTableBodyNone">Last action happening for a vertex. As we traverse the tree top-down, all the coarser parent data are still valid and no touchLastXXX event has been called for those guys.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">createHangingFace   </td><td class="markdownTableBodyNone">Invoked in the context of adaptive meshes. Hanging faces are not persistent aka stored in-between two mesh traversals. Used to project data from the next coarser level onto the hanging entity.   </td><td class="markdownTableBodyNone">Called before any event for an adjacent cell is invoked.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">destroyHangingFace   </td><td class="markdownTableBodyNone">Invoked in the context of adaptive meshes. Hanging faces are not persistent aka stored in-between two mesh traversals and hence are destroyed for every creation encountered per mesh sweep.   </td><td class="markdownTableBodyNone">Precedes the destruction of adjacent hanging vertices.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">touchVertexFirstTime   </td><td class="markdownTableBodyNone">Invoked when vertex is loaded for the first time or directly after its creation.   </td><td class="markdownTableBodyNone">Pior to any other operation on this vertex or an adjacent face or cell. Called directly after createPersistentVertex if this is a brand new vertex. All first and creational events on all coarser data have been called before.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">touchVertexLastTime   </td><td class="markdownTableBodyNone">Invoked when vertex is accessed for the last time in this mesh sweep.   </td><td class="markdownTableBodyNone">After all adjacent cells have been traversed and all "last" operations on all adjacent faces and cells have complted. destroyPersistentVertex is the only event that might be called afterwards for this vertex in this sweep if the mesh erases. All first and creational events on all coarser data have been called before.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">touchFaceFirstTime   </td><td class="markdownTableBodyNone">Invoked when face is loaded for the first time.   </td><td class="markdownTableBodyNone">Invoked after touchVertexFirstTime for adjacent vertices. Precedes event on the two adjacent cells. All first and creational events on all coarser data have been called before.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">touchFaceLastTime   </td><td class="markdownTableBodyNone">Invoked when face is accessed for the last time in this mesh sweep.   </td><td class="markdownTableBodyNone">After all adjacent cells have been traversed (see touchCellLastTime). All first and creational events on all coarser data have been called before.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">touchCellFirstTime   </td><td class="markdownTableBodyNone">Invoked when we hit the cell.   </td><td class="markdownTableBodyNone">After all adjacent hanging faces and vertices have been created. You can assume that touchXXXFirstTime for the persistent adjacent grid entities has been called. Also, all first events on all coarser data have been called before.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">touchCellLastTime   </td><td class="markdownTableBodyNone">Invoked when the traversal automaton moves from fine to coarse cells within the spacetree.   </td><td class="markdownTableBodyNone">Called once all events on finer levels on children within the spacetree have been called.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td><td class="markdownTableBodyNone">----------&mdash;   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1004"></a>
Example</h2>
<p>We illustrate some of this behaviour by means of a sketch we usually use to explain domain decomposition. So please ignore the colours of the cells in this example:</p>
<div class="image">
<img src="../../replicated-boundary-data.png" alt=""/>
</div>
<p>In a serial code, Peano runs through the mesh. Here's some statements on events triggered throughout the traversal:</p>
<ul>
<li>Before it kicks off the traversal, beginTraversal() is called.</li>
<li>When the code hits cell A, it first of all calls touchVertexFirstTime() on the green vertex, as this vertex has never been used before. This is the only time touchVertexFirstTime() is called for this particular vertex.</li>
<li>We get a touchCellFirstTime() event for cell A. At this point, we know that touchVertexFirstTime() has been called once and exactly once for all \( 2^d \) adjacent vertices.</li>
<li>As the cell is not refined further, we immediately get a touchCellLastTime() after the touchCellFirstTime().</li>
<li>When we continue the right neighbour, we'll invoke touchVertexFirstTime() on the red vertex. However, such knowledge should not be encoded into any action set logic.</li>
<li>At one point later throughout the traversal, we'll get a touchCellLastTime() for cell B.</li>
<li>After this one has returned, Peano knows that the green vertex will never be used by any of its \( 2^d \) adjacent cells, i.e. we know that touchCellLastTime() has been called for all of these guys. Consequently, the code will now invoke touchVertexLastTime() on the green guy. This event is also called exactly once throughout the traversal.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1005"></a>
Markers</h2>
<p>Whenever you encounter a face, vertex or cell, Peano's action sets will be given a single or set of the grid entities. That is, for each vertex, face and cell data set, the corresponding events will get a reference or pointer to them. So now you can manipulate them.</p>
<h3><a class="anchor" id="autotoc_md1006"></a>
Spatial information on context</h3>
<p>Cells, faces and vertices do not carry information such as position. They also do not know if they are local, they are hanging, ... Such information is held separatedly. We actually do not hold it at all, but compute it on-the-fly within the Peano core. To the action set, the information is exposed through a marker object. That is, every action set is also passed a marker object which you can query to get this information.</p>
<p>Please note that all grid entities seem to hold positions and mesh sizes. However, these properties are only available in debug mode and should not be used by user code. I use them to print out meaningful debug data (so you know where the code is within the mesh) and I use them within assertions to check if the grid is consistent, i.e. Peano's core stores the right mesh data at the right place.</p>
<p>The markers of relevance are</p>
<ul>
<li><a class="el" href="../../dd/dc6/structpeano4_1_1datamanagement_1_1VertexMarker.html" title="Vertex marker to provide information about selected vertex.">peano4::datamanagement::VertexMarker</a></li>
<li><a class="el" href="../../df/dd3/structpeano4_1_1datamanagement_1_1FaceMarker.html" title="Provide information about selected face.">peano4::datamanagement::FaceMarker</a></li>
<li><a class="el" href="../../dc/d59/structpeano4_1_1datamanagement_1_1CellMarker.html" title="Cell marker.">peano4::datamanagement::CellMarker</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md1007"></a>
Multiscale data</h3>
<p>The actions reacting to events, i.e. operations within the action set, also have access to the direct parent data one level coarser. Peano always only passes through pointers to coarser data. For each vertex data, you will for example get one pointer to the corresponding data. To access the right data, Peano passes in an enumerator object. You have to use the enumerator to pick the correct element from the array identified by the pointer.</p>
<p>Enumerators of interest are:</p>
<ul>
<li><a class="el" href="../../d2/d29/structpeano4_1_1datamanagement_1_1VertexEnumerator.html" title="Vertex enumerator within array.">peano4::datamanagement::VertexEnumerator</a></li>
<li><a class="el" href="../../dc/da6/classpeano4_1_1datamanagement_1_1FaceEnumerator.html" title="Enumerator over an array of faces.">peano4::datamanagement::FaceEnumerator</a></li>
</ul>
<p>There's no cell enumerator, as you never get more than one cell.</p>
<h2><a class="anchor" id="autotoc_md1008"></a>
Sequence and parallelisation of actions</h2>
<div style="background-color: #ccf ; padding: 10px; border: 1px solid green;"> The term parallelisation here has noting to do with domain decomposition. It simply means that you might want to do various things for a cell/vertex/face when you hit it for the first/last time and these things can run in parallel. <a class="el" href="../../d4/d00/page_peano_domain_decomposition.html">Domain decomposition is discussed separatedly</a>. </div><p>An algorithmic step (Observer) within Python corresonds 1:1 to a class of the type <a class="el" href="../../d5/dc1/classpeano4_1_1grid_1_1TraversalObserver.html">peano4::grid::TraversalObserver</a>, and it holds a set of actions. Actions are represented by the Python class <a class="el" href="../../d8/d95/namespacepeano4_1_1solversteps_1_1ActionSet.html">peano4.solversteps.ActionSet</a>. Each action set within an observer (algorithmic step) has two relevant properties:</p>
<ul>
<li>descend_invocation_order</li>
<li>parallel</li>
</ul>
<p>These flags (set in the constructor) give the user control over the order of the actions for each even throughout the traversal. They also allow you to specify if events can run in parallel. Again: This is the control how two touchCellFirstTime() events from two different action sets are triggered <em><b>for the same cell</b></em> on one tree simultaneously. It has nothing to do with data decomposition, i.e. how the trees are split. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../dd/da2/page_peano4_home.html">Peano 4</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:05 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
