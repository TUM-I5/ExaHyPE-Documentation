<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/de2/page_toolbox_particles_mesh_traversal.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Mesh traversal</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A summary of how Peano runs throug the mesh and builds up the active and local sets which are then used to realise particle-particle interactions.</p>
<p>Peano realises mesh sweeps via tree walkers, i.e. automata which run through the tree top down and then bottom up again. Each algorithm step equals one complete mesh traversal of all mesh resolutions. Throughout this traversal, the automaton triggers events (or observations) that are then mapped onto <a class="el" href="../../da/d1b/peano_action_sets.html">action sets</a>.</p>
<p>While running through the mesh, i.e. spacetree, the automaton maintains different particle sets. For the construction rules, it is important to keep in mind that vertices of any level hold only particles whose search radius is stricly smaller or equal to the corresponding mesh size. Particles with a large search radius are consequently stored on coarser levels. This allows us to define our particle sets:</p>
<ul>
<li>Particles associated with local, persistent (non-hanging) vertices of a cell. This set, called localParticles, holds all the particle pointers of particles that reside on the same resolution level as the set's vertex and where the current vertex is the closest one to the particles' coordinates.</li>
<li>The set of active particles is the local set plus the active set from the father cell in the spacetree. This is a recursive definition. So the set of active particles holds all local particles plus all the particles of coarser levels which might overlap with a local particle whose centre is within the current cell.</li>
<li>The particles associated to a single vertex.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1231"></a>
Example</h1>
<p>The illustration below shows two levels of a spacetree with bipartitioning (although we use tri-partitioning in Peano). There are eight particles in this example. The tree automaton is currently in the finer, dark blue cell and triggers touchCellFirstTime().</p>
<div class="image">
<img src="../../dependency_sets.png" alt=""/>
</div>
<ol type="1">
<li>The set of local particles of this cell consists of four particles. It is the red particle - which is kind of trivial. However, also contains the three dark green particles, as the local set consists of all particles which are tied to the adjacent vertices and each particle is stored within the closest vertex.</li>
<li>The yellow particles is too far away and is not part of the local set.</li>
<li>Three particles have a large search radius and hence are stored on a coarser mesh level. They are not part of the local set at this point.</li>
<li>Consequently, the set of local particles comprises all of the particles whose centre is contained within the cell plus a halo of h/2. This is the dotted area around the cell.</li>
<li>The set of active particles is built up recursively and hence comprises all local particles. It is a strict superset.</li>
<li>As the active particles are built up recursively, the active particles also comprise the light blue particles and the light green one.</li>
<li>The orange particle is too far away (more than h/2 on the coarser mesh) to be a member of the coarse cell's local particle set. It hence is also not a member of the active set of the fine cell.</li>
</ol>
<p>We need the local and active sets to cover an area that is bigger than the actual cells, as we want to capture all particles of this level that might theoretically interact with the particles located within the cell.</p>
<h1><a class="anchor" id="autotoc_md1232"></a>
Uniqueness, correctness and data consistency</h1>
<h2><a class="anchor" id="autotoc_md1233"></a>
Multiple particle reads per traversal</h2>
<p>If you want to update particles within a cell, you should introduce a boolean per particle that indicates if you have already touched it or not. The particle-to-cell association is not unique: isContained() has to work with a slack, as it deals with floating point numbers. If a particle resides on the face between two cells, it hence is contained within both cells. You might update it twice if you work within touchCellFirstTime() or touchCellLastTime(). I therefore recommend to add a boolean per particle which highlights if a particle has already been updated.</p>
<div class="image">
<img src="../../particle-uniqueness.png" alt=""/>
</div>
<p>The illustration above highlights the problem: The blue particle sits exactly on the face between two cells. It is associated to the bottom vertex (dotted line). When we update it within the red cell, we will later on also update it one more when we hit the green cell. So we need a marker. Most codes unset this marker in touchVertexFirstTime() for all local particles, so it is properly initialised. The update then sets the marker to keep books which particles have been updated and which haven't.</p>
<h2><a class="anchor" id="autotoc_md1234"></a>
Particle-particle interactions on one level</h2>
<p>If you want to update particles of a cell due to particle-particle interactions, you should only update particles which hold the right value of the corresponding flag plus whose centre is within the cell: Particles belong to the local sets of up to \( 2^d \) surrounding vertices. If you want to update the red particle vs.~the green one left above it in the sketch above, it becomes immediately clear that the green particle will be in the local set of this cell, but also in the local set of the cell left of it and also the one left above it.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (</div>
<div class="line">  not p-&gt;whatever your marker is called</div>
<div class="line">  and</div>
<div class="line">  marker.isContained( p-&gt;getX()</div>
<div class="line">) {</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ensure somewhere later that marker is set</div>
</div><!-- fragment --><p>is your friend. We illustrate this above by means of yellow particle which has an impact on the orange particle. We can update the orange particle with the impact from the yellow particle when we hit the red cell. However, the orange particle is also in the local set of the green cell. If we updated the orange particle there, we would miss the yellow one.</p>
<p>As the local particle set is a subset of the active set, you will compare a particle to itself if you simply compare the particles of the active set against the particles in the local set. This requires an additional if in most kernels.</p>
<p>All of these remarks do not apply if you work within touchVertexFirstTime() or touchVertexLastTime(). Here, the set of particles associated with the vertex is unique. However, you cannot compute any proper particle-particle interaction here, as you don't have the active sets of the neighbouring vertices.</p>
<p>Our scheme at the moment does not provide any means to exploit force symmetries between cells. However, you can tailor compute kernels to exploit any symmetry you want.</p>
<h1><a class="anchor" id="autotoc_md1235"></a>
Interaction types</h1>
<h2><a class="anchor" id="autotoc_md1236"></a>
Single level interactions</h2>
<p>If particles can only interact with their level, you can use <a class="el" href="../../df/d14/namespacepeano4_1_1toolbox_1_1particles_1_1UpdateParticle__SingleLevelInteraction.html">peano4.toolbox.particles.UpdateParticle_SingleLevelInteraction</a> or <a class="el" href="../../d3/d07/namespacepeano4_1_1toolbox_1_1particles_1_1UpdateParticle__SingleLevelInteraction__ContiguousParticles.html">peano4.toolbox.particles.UpdateParticle_SingleLevelInteraction_ContiguousParticles</a>. Both types differ in their assumptions of how the particles are organised in memory. Other than that, their realisation is rather straightforward:</p>
<p>As particles are tied to vertices, we know that a particle has not been read prior to the touchVertexFirstTime() for the corresopnding vertex. We let touchVertexFirstTime() imply an event alike touchParticleFirstTime(). If a cell is hit, we know that all of its vertices have been read, and therefore all of its particles have been. After we have touched a vertex for the last time, we also won't access its particles anymore.</p>
<h2><a class="anchor" id="autotoc_md1237"></a>
Multiscale interactions</h2>
<p>Each particle has an attribute getCellH() which provides the user code information about the cell currently holding the particle. That is, whenever one of the update action sets moves particles up or down in the mesh hierarchy due to particle state changes or adaptive mesh refinement, it will automatically adopt the cell h.</p>
<p>We can exploit this property to implement valid multiscale interactions: If two particles L (local) and A (active) are on the same grid level, we evaluate A-B and B-A separately, i.e. once draw A from the local set and B from the active set and then the other way round. That is, we evaluate a function \( f(L,A) \), knowing that \( f(A,L) \) will be done later in the neighbour cell, e.g. Notably, we do not exploit</p>
<p>\(
 f(L,A) = -f(A,L)
\)</p>
<p>and similar relations, even though they are omnipresent in Lagrangian formalisms.</p>
<p>The assumption that the counterpart will be taken care of is wrong if A resides on a coarser level than L. Local particles see all (active) particles from coarser scales, but coarse scale data doesn't see fine scale data. So if the particle's cell size \( h(A)&gt;h(L) \), then we have evaluated \( f(A,L) \) immediately as well within the loop. If we evaluate \( f(A,L) \) for \( h(A)=h(L) \), it will be evaluated twice - which is bad if the evaluation feeds into an accumulation.</p>
<h1><a class="anchor" id="autotoc_md1238"></a>
Moving particles and particle sorting</h1>
<p>The construction of the active and local sets works if and only if the particles are correctly assigned to mesh vertices. That is, they have to be stored within their closest vertex on the right mesh level in line with <a class="el" href="../../d0/d45/page_toolbox_particles_mesh_storage.html">our storage conventions</a>.</p>
<p>The very moment you alter a particle position, you might violate the correct assignment. From this point on, the local and active sets are corrupted, i.e. might hold too many particles or miss a few. Most codes equip the particles with markers (updated) and do not move particles directly. Instead, they maintain two positions - the current x and a xNew - and then copy the xNew over into x when a vertex is touched for the last time. This way, the local and active sets deliver correct snapshots of the system described by x and are hence correct.</p>
<p>Once we have assigned particles a new position (or a new search radius), we have to re-sort them. This is required to preserve the <a class="el" href="../../db/d91/page_toolbox_particles_mesh_consistency.html">particle-mesh consistency</a>. It is important to keep in mind that particle sorting requires at least two mesh sweeps. That is, once you change a particle position, the new valid particle-vertex association might not be in place in the next mesh sweep. Therefore, the active and local sets might be corrupted in the next sweep. They will be fine once all drops have finished. This fact requires some further attention:</p>
<p>If a particle has changed its position or search radius in mesh sweep n, it might not be assigned to the correct vertex anymore. Some particle sorting (cmp discussion of variants in <a class="el" href="../../db/d91/page_toolbox_particles_mesh_consistency.html">Sorting: Preserving the mesh-particle data consistency</a>) might be able to handle some of these cases, i.e. put some particles straight into the right vertices, but all sorting approaches might run into situations where they have to lift particles to the next coarser level. In the iteration n+1, a particle hence might reside on a coarser level and will be dropped. However, if we plug into touchCellFirstTime(), these drops have not yet happened. That is, the particle currently resides on the wrong level and consequently messes up our active and passive particle sets.</p>
<p>There are work-arounds. For example, you can check via</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (</div>
<div class="line">  not p-&gt;whatever your marker is called</div>
<div class="line">  and</div>
<div class="line">  marker.isContained( p-&gt;getX()</div>
<div class="line">  and</div>
<div class="line">  not particleWillBeDroppedFurther( *p, marker )</div>
<div class="line">) {</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">ensure somewhere later that marker is set</div>
</div><!-- fragment --><p>that you don't double-count particles. However, at the end of the day it is all a mess. If you need particle-particle interactions after a move, insert some "empty" mesh traversals to get the sorting right.</p>
<p>Here is an illustration what can go wrong:</p>
<div class="image">
<img src="../../particle-drop.png" alt=""/>
</div>
<p>The blue particle has moved into the green position in mesh sweep n. In mesh sweep n+1, we hit the cell in which the blue particle (now green) has ended up. We construct the active set and have no other interacting particles. So we should not update it. That is what the if statement using particleWillBeDroppedFurther() is for. Instead, we handle whatever we do on the refined coarse cell, ignoring the particle, and then descend. Throughout the descend, the particle will be dropped onto the next finer level. Now, the dropped green particle will see the orange neighbours.</p>
<p>Checking particles with</p>
<div class="fragment"><div class="line">particleWillBeDroppedFurther( *p, marker )</div>
</div><!-- fragment --><p>can be very problematic along AMR boundaries, and <a class="el" href="../../db/de5/namespacepeano4_1_1toolbox_1_1particles_1_1api_1_1AbstractUpdateParticleGridAssociation.html">peano4.toolbox.particles.api.AbstractUpdateParticleGridAssociation</a> discusses these effects in detail using the arrangement below:</p>
<div class="image">
<img src="../../SievingAlongAMRBoundaries.png" alt=""/>
</div>
<p>The problems arise for particles associated to the coarser level which you might want to sort into a hanging vertex on the next finer level. We never sort into hanging vertices, and this leads to the observation that multiscale interactions are mandatory in Peano even if you work only with the finest level logically.</p>
<p>The page <a class="el" href="../../db/d91/page_toolbox_particles_mesh_consistency.html">Sorting: Preserving the mesh-particle data consistency</a> discusses various aspects of this sorting and how it helps to keep the mesh-particle assocations consistent.</p>
<h1><a class="anchor" id="autotoc_md1239"></a>
Set realisations</h1>
<p>The particle toolbox offers two flavours of both type of particle interactions:</p>
<ul>
<li><a class="el" href="../../db/d5c/namespacepeano4_1_1toolbox_1_1particles_1_1UpdateParticle__MultiLevelInteraction__StackOfLists__ContiguousParticles.html">peano4.toolbox.particles.UpdateParticle_MultiLevelInteraction_StackOfLists_ContiguousParticles</a> vs <a class="el" href="../../da/db6/namespacepeano4_1_1toolbox_1_1particles_1_1UpdateParticle__MultiLevelInteraction__Sets.html">peano4.toolbox.particles.UpdateParticle_MultiLevelInteraction_Sets</a>, and</li>
<li><a class="el" href="../../df/d14/namespacepeano4_1_1toolbox_1_1particles_1_1UpdateParticle__SingleLevelInteraction.html">peano4.toolbox.particles.UpdateParticle_SingleLevelInteraction</a> vs <a class="el" href="../../d3/d07/namespacepeano4_1_1toolbox_1_1particles_1_1UpdateParticle__SingleLevelInteraction__ContiguousParticles.html">peano4.toolbox.particles.UpdateParticle_SingleLevelInteraction_ContiguousParticles</a>.</li>
</ul>
<p>For all of them, particle sets are not persistent, i.e. they are built up on-the-fly. Yet, the realisation can make certain assumptions about their memory layout. These assumptions are discussed on a subpage of the <a class="el" href="../../db/dba/page_toolbox_particles_realisation.html">Realisation details</a>.</p>
<h1><a class="anchor" id="autotoc_md1240"></a>
For Swift 2 users:</h1>
<ul>
<li>See <a class="el" href="../../d0/daf/namespaceswift2_1_1particle_1_1Particle.html">swift2.particle.Particle</a> for the introduction of the marker CellHasUpdatedParticle which we use to ensure that each particle is only updated once.</li>
<li>Consult <a class="el" href="../../d9/d13/namespaceswift2_1_1actionsets_1_1UpdateParticleMarker.html">swift2.actionsets.UpdateParticleMarker</a> for documentation of the action set which actually sets the marker.</li>
<li>Read through swift2.graphcompiler.Sequential for an example how and when the different active set construction schemes are used.</li>
<li>Read through swift2.graphcompiler.Sequential for an example how and when to invoke UpdateParticleMarker to ensure that the update markers are always set to the correct value.</li>
<li>Read through the recommendations on <a class="el" href="../../d3/dc8/page_swift_performance_optimisation.html">Performance optimisation</a>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d7/d66/page_toolbox_home.html">Toolbox</a></li><li class="navelem"><a class="el" href="../../d0/d9e/toolbox_particles.html">Particles</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:07 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
