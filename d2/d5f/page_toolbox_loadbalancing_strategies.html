<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/d5f/page_toolbox_loadbalancing_strategies.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Load balancing strategies</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1209">Problem formulation</a><ul><li class="level2"><a href="#autotoc_md1210">Terminology</a></li>
<li class="level2"><a href="#autotoc_md1211">Tree manipulation</a></li>
<li class="level2"><a href="#autotoc_md1212">Tree construction</a></li>
<li class="level2"><a href="#autotoc_md1213">Objective</a></li>
<li class="level2"><a href="#autotoc_md1214">Challenge</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1215">Offline Problem Summary</a></li>
<li class="level1"><a href="#autotoc_md1216">Observations</a></li>
<li class="level1"><a href="#autotoc_md1217">Extensions</a><ul><li class="level2"><a href="#autotoc_md1218">Chains on chains</a></li>
<li class="level2"><a href="#autotoc_md1219">Weighted graph nodes</a></li>
<li class="level2"><a href="#autotoc_md1220">Guided refinement</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1221">Example</a><ul><li class="level2"><a href="#autotoc_md1222">Online Two Spliting</a></li>
<li class="level2"><a href="#autotoc_md1223">Offline Triple Spliting</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md1209"></a>
Problem formulation</h1>
<h2><a class="anchor" id="autotoc_md1210"></a>
Terminology</h2>
<p>We have tree \( \mathcal{T} \) where each node has either 0 or \( k^d \) children, and \( k,d \in \{2,3\} \) are fixed constants. The level \( \ell(n) \) is the distance from the tree's root \( n_0 \) in graph. Let \( n_i \sqsubseteq_{\text{child of}} n_j, \  n_i,n_j \in \mathcal{T} \) denote that \( n_i \) is a child of \( n_j \), i.e. there's an edge from \( n_i \) to \( n_j \) and \( \ell (n_i) = \ell (n_j) + 1 \). Nodes \( \mathcal{T}_{leaves} = \{ n \in \mathcal{T}: \not \exists j: n_j \sqsubseteq_{\text{child of}} n  \} \) are the leaves of the tree.</p>
<p>We also have a set \( \mathcal{P} = \{p_0, p_1, \ldots, p_{N_{comp}-1} \} \) of compute resources. Let \( C: \mathcal{T} \mapsto \mathcal{P} \) assign each tree node to a compute resource.</p>
<h2><a class="anchor" id="autotoc_md1211"></a>
Tree manipulation</h2>
<p>There is only one operation available: \( split(p_i, p_j, n, N) \) operates on \( \{ n_k: C(n_k)=p_i \} \neq \emptyset \) and \( \{ n_l: C(n_l)=p_j \} = \emptyset \). It takes \( n \leq \hat n \) leaf nodes assigned to \( p_i \) and assigns them to \( p_j \). Hereby, \( \hat n \) is the number of leaf nodes associated to \( p_i \). The split consequently might also reassign some non-leaf nodes. \( N \) is the total size of the current tree. The movement of the non-leaf nodes must following the tree topology: if the parent and at least one child of a node are both associated to \( p_i \), then this non-leaf node must be associated to \( p_i \) as well.</p>
<p>W.l.g. we may assume that the root \( n_0 \) is originally assigned to the first available compute resource: \( C(n_0) = p_0 \).</p>
<p>Notice we can not merge subtrees, i.e., split is not allowed to operate if \( \{ n_l: C(n_l)=p_j \} \neq \emptyset \). The splitted subtree can continue to construct to following levels without any further cost (see next section, and the example section).</p>
<h2><a class="anchor" id="autotoc_md1212"></a>
Tree construction</h2>
<p>The tree is not constructed in one rush. It originally consists solely of the root node. After that, we add one more level per step. After \( \ell_{max} \) steps, the tree is complete. We build it up level by level.</p>
<p>The \( \ell_{max} \) is known a priori. So is a \( \ell_{min} \) which is the minimal distance from any leaf node, i.e. unrefined node to the tree's root in the final tree. Throughout the grid construction, \( \ell &lt; \ell_{max} \) is admissible for an unrefined node, and even \( \ell &lt; \ell_{min} \leq \ell_{max} \) will occur early throughout the mesh construction. Once the tree construction has terminated, we however guarantee \( \ell_{min} \leq \ell(n) \leq \ell_{max} \) for each leaf.</p>
<p>By default, any new node that is added to the tree is assigned to the compute entity its parent has been assigned to. \( n_i, n_j \in \mathcal{T}: \ n_i \sqsubseteq_{\text{child of}} n_j \Rightarrow C(n_i) = C(n_j) \). Only the slits can change this transition afterwards. Without any split operations, the whole tree would eventually be associated to the root's compute resource \( C(n_0) = p_0 \).</p>
<h2><a class="anchor" id="autotoc_md1213"></a>
Objective</h2>
<p>Due to a sequence of split calls, we want to construct a mapping \( C \), such that</p>
<p>\( \forall p_i,p_j: \ \mathcal{T}_{leaves}(p_i) \approx \mathcal{T}_{leaves}(p_i) \)</p>
<p>where \( \mathcal{T}_{leaves}(p) = \{ n \in \mathcal{T}_{leaves}: C(n)=p \} \). We want to have a well-balanced assignment of leaves to processing units. The \( \approx \) sign is used, as we work with integers and hence cannot ensure exact equality. We might also be willing to accept a small, fixed deterioration from the optimum.</p>
<p>For a more advance metric of measuring the quality of the splitting, we introduce the splitting quality score \( w=C_2 \cdot \text{SplitCost}+C_1 \cdot \text{Imbalance} \), where \( \text{SplitCost}=\sum F(split(...)) \) is the sum up of costmetric output for every split operation (see next section), and \( \text{Imbalance}=MAX(\mathcal{T}_{leaves}(p_i)+C_3 \text{Surface}(p_i)) - MIN(\mathcal{T}_{leaves}(p_i)+C_3 \text{Surface}(p_i)) \). \(\text{Surface}(p_i)\) is the spatial boundaries for the subtree associated with \( p_i \), as the tree represents an adaptive refinement of a spatial domain. The smaller the quality score is, the better the splitting algorithm is.</p>
<p>In the current problem, \( C_3 \ll 1 \). i.e., for now, we do not care too much about the surface size as long as all leaves are spatially connected. For online problem where we do not know the tree structure in advance, We also set \( C_2 \ll C_1 \) (holds even for the superlinear model of splitting cost), i.e., the balance among compute resources is the top priority. For offline problem it does not hold anymore and we would like a low-cost spliting process as well.</p>
<h2><a class="anchor" id="autotoc_md1214"></a>
Challenge</h2>
<p>This challenge in principle is very simple: We take the whole tree, count the number of leaves and issue a series of splitting calls. However, we want to make the splitting as cheap as possible: There is a cost function \( F( split(p_i, p_j, n, N) ) \) which depend on both in the number \( n \) (the number of leaves moved) and \( N \) (toal size of current tree). Due to the cost function, it consequently might be reasonable to issue splits while the tree is constructed and not at the very end, where \( N \) would become rather big.</p>
<p>In online problem, unfortunately, we do not know what the tree eventually will look like. We have guarantees regarding the minimum and maximum level of each node, but no further domain knowledge. On the other hand, in offline problem we know the complete structure of the tree, thus make lives much easier. Conclusively, the development of an "optimal" splitting strategy is not straightforward. We permanently have to balance between an eager decision to split, which is cheap yet might introduce the wrong splits that we cannot undo later, or waiting for further information which might make future splits more accurate but excessively expensive.</p>
<h1><a class="anchor" id="autotoc_md1215"></a>
Offline Problem Summary</h1>
<p>An offline problem means that we first construct the tree once without any splitting. And then restart from the beginning to do the split with the information of the whole tree. It can avoid the biggest problem in the online version: we can not make clever decisions as we know nothing about the future. Achieving low imbalance is easy in this case, and thus, the leading measure of split quality would be split cost. Several important remarks for the offline version of splitting:</p><ol type="1">
<li>we can still only split subtree as described above, so not merge or delete subtree.</li>
<li>The split cost function depends on both \( n \) and \( N \), a simple model would be \( F( split(p_i, p_j, n, N) )=A_1 n + A_2 N \), though we do not know the ratio between \( A_1 \) and \( A_2 \).</li>
<li>the formulation of the quality score above still holds, however, as an offline problem, finding a minimum of \( \text{Imbalance} \) is always possible using a bottom-up algorithm (e.g., SFC-based traversal), therefore the goal of a good algorithm would be reducing splitcost.</li>
<li>The surface term is still in low priority as long as leaves in one subtree are connected ( \( C_3 \ll 1 \)).</li>
<li>The idea of offline is to utilize the information of the whole tree to do the splitting operation as early as possible.</li>
<li>It is because the tree is constructed layers by layers, thus an early split at a lower level costs much less than a later split.</li>
</ol>
<p>The example section below can be helpful in understanding the offline splitting further.</p>
<h1><a class="anchor" id="autotoc_md1216"></a>
Observations</h1>
<p>The topology over \( \mathcal{P} \) is a tree topology in itself, i.e. the way how we split the tree introduces a tree topology over the individual compute entities.</p>
<h1><a class="anchor" id="autotoc_md1217"></a>
Extensions</h1>
<h2><a class="anchor" id="autotoc_md1218"></a>
Chains on chains</h2>
<p>In reality, the set \( \mathcal{P} \) is hierarchical in itself, i.e. it is actually a \( \mathcal{P} = \{ p_{0,0}, p_{0,1}, \ldots, p_{0,N_{cores}-1}, p_{1,0}, p_{1,1}, \ldots, p_{N_{nodes}-1,0}, \ldots, p_{N_{nodes}-1,N_{cores}-1} \} \). A good partition minimises</p>
<p>\( n_i \sqsubseteq_{\text{child of}} n_j \ \text{with} \ C(n_i)=p_{a,b} \wedge C(n_j)=p_{c,d}: a \not= c \)</p>
<h2><a class="anchor" id="autotoc_md1219"></a>
Weighted graph nodes</h2>
<p>In the outline challenge, all leaves are considered to have the same weight. However, it is possible that we introduce weights for each individual (interior) node.</p>
<p>The notion of leaves changes over time: As we build up the tree level by level, a node that has been a leaf at one point (and did feed into a split's cost function at this point) might become refined later on. While we do not know, in general, what the tree will look like, a lot of problems can provide indicators (it is likely that we'll refine up to a level \( \ell \geq \ell _{\text{min}} \) in this area) and consequently can assign a tree node which eventually becomes a refined one a weight that's bigger than other nodes. A lot of application codes can map their domain-specific knowledge about what the tree might look like onto a non-uniform cost metric.</p>
<h2><a class="anchor" id="autotoc_md1220"></a>
Guided refinement</h2>
<p>In the vanilla version of the code, we assume that the tree is built up level-by-level. While the underlying simulation code constructs the tree in this way at the moment, we can alter the code such that the splitting algorithm decides where the tree is allowed to refine in the next step.</p>
<p>It is not clear if such a degree of freedom is of any use, but in principle it allows an algorithm to query more information about the tree before it continues, i.e. it can hold back with splitting decisions and instead tell the algorithm to continue to construct the tree (in certain areas) before it comes to its next decision.</p>
<h1><a class="anchor" id="autotoc_md1221"></a>
Example</h1>
<h2><a class="anchor" id="autotoc_md1222"></a>
Online Two Spliting</h2>
<p>We provide an example of (online) tree splitting. Below is a tree of four levels, where only the first nodes on levels 1 and 2 have children. The tree is constructed level by level, going through stages (I) to (IV). As we only have the split operation, the three good two-split candidates can be</p>
<div class="image">
<img src="../../visualise_tree_split_example0.png" alt=""/>
</div>
<p>(1) split the first node in stage (II) to the second tree and finish the following construct. The imbalancing would be \( |7C_1-3C_1|=4C_1 \) (omit the surface term), with a split cost of \( C_2(A_1 + 4A_2) \) (assuming linear costmetric). The total quality score would be \( 4C_1+C_2(A_1 + 4A_2) \) (the smaller the better).</p>
<div class="image">
<img src="../../visualise_tree_split_example1.png" alt=""/>
</div>
<p>(2) split the first two nodes in stage (III) to the second tree and finish the following construct. The imbalancing would be \( |5C_1-5C_1|=0 \), with a split cost of \( C_2(2A_1 + 7A_2) \). The total quality score would be \( 2C_2(2A_1 + 7A_2) \).</p>
<div class="image">
<img src="../../visualise_tree_split_example2.png" alt=""/>
</div>
<p>(3) Split the first two nodes on level 2 and all in level 3 in stage (IV) to the second tree. The imbalance would be \( |5C_1-5C_1|=0 \), with a split cost of \( C_2(5A_1 + 10A_2) \) (number of leaves moved). The total quality score would be \( C_2(5A_1 + 10A_2) \).</p>
<p>It is quite clear that option (1) is not good as it chooses an early, aggressive tree splitting, though the splitting cost is cheap, the heavy imbalance indicates it is not a good strategy. Comparing options (2) and (3) is a little more tricky: (2) has a smaller score, however, it has to "foresee" that the first node is going to be refined to make this clever decision. (3), on the other hand, does not have this issue, as at stage (IV) the tree has been constructed completely. Of course, it then has to pay the price for moving more nodes in the split operation.</p>
<p>To summarise, option (1) is not acceptable, option (3) is acceptable but expensive, and option (2) is best but requires a clever splitting strategy. For the corresponding offline version of this example, (3) is quite easy to find and we hope a good algorhitm to find (2) efficiently. It is more practical in offline version because we do know the future at stage (III) in this case.</p>
<h2><a class="anchor" id="autotoc_md1223"></a>
Offline Triple Spliting</h2>
<p>Here we provide a example of splitting on the same tree, but now triple splitting from an offline problem prespective.</p>
<div class="image">
<img src="../../visualise_tree_split_example3.png" alt=""/>
</div>
<p>There are multiple ways to split the tree with minimum leaf imbalance (again we drop surface term), which is \( 3:3:4 \). However they are from different splitting processes:</p><ol type="1">
<li>Start with green, split 4 yellow at level 2, split 3 red at level 3. Total cost \( C_2(4A_1 + 7A_2 + 3A_1 + 10A_2) = C_2(7A_1 + 17A_2) \)</li>
<li>Start with red, split 4 yellow at level 2, split 3 green at level 3. Total cost \( C_2(4A_1 + 7A_2 + 3A_1 + 10A_2) = C_2(7A_1 + 17A_2) \)</li>
<li>Start with yellow, split 1 red at level 1, split 3 green at level 3. Total cost \( C_2(1A_1 + 4A_2 + 3A_1 + 10A_2) = C_2(4A_1 + 14A_2) \)</li>
<li>Start with yellow, split 1 red at level 1, split 1 green at level 2. Total cost \( C_2(1A_1 + 4A_2 + 1A_1 + 7A_2) = C_2(2A_1 + 11A_2) \)</li>
</ol>
<p>It is obvious (4) have the lowest cost of splitting, and it is because it makes better split decisions at early stage of tree construction, while keep the leaves imbalance unchanged. Now the problem is: given the structure of an arbitrary tree, can we find an algorithm to find the good splitting like (4)? </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d7/d66/page_toolbox_home.html">Toolbox</a></li><li class="navelem"><a class="el" href="../../d1/de1/toolbox_loadbalancing.html">Load Balancing (Domain Decomposition)</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:07 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
