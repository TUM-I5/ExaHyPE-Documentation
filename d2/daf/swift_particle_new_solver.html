<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/daf/swift_particle_new_solver.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Creating new particle types (solvers) with new algorithmic steps</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1117">Introduce a new particle type</a><ul><li class="level2"><a href="#autotoc_md1118">Declaring particle attributes</a></li>
<li class="level2"><a href="#autotoc_md1119">The algorithmic steps for the particle life cycle</a><ul><li class="level3"><a href="#Section_SwiftAlgorithmStepsInitialization">The algorithmic steps for the particle initialisation</a></li>
<li class="level3"><a href="#autotoc_md1120">Remarks on particular particle update steps</a><ul><li class="level4"><a href="#autotoc_md1121">Drifts (movements)</a></li>
<li class="level4"><a href="#autotoc_md1122">Interaction range calculation</a></li>
<li class="level4"><a href="#autotoc_md1123">Multiscale interactions</a></li>
<li class="level4"><a href="#autotoc_md1124">Reruns of steps</a></li>
<li class="level4"><a href="#autotoc_md1125">Iterators</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1126">New solver kernels (physics)</a></li>
<li class="level1"><a href="#autotoc_md1127">Cut-off radius realisation (e.g. in the force calculation)</a></li>
<li class="level1"><a href="#autotoc_md1128">Tune a kernel realisation</a><ul><li class="level2"><a href="#autotoc_md1129">Move checks out of the kernels</a></li>
<li class="level2"><a href="#autotoc_md1130">Step 2: Switch to a bespoke iterator</a></li>
<li class="level2"><a href="#autotoc_md1131">Step X: Port kernels to GPUs</a></li>
<li class="level2"><a href="#autotoc_md1132">Troubleshooting: The kernel does not vectorise despite all these steps</a><ul><li class="level3"><a href="#autotoc_md1133">Expose all particle attributes</a></li>
<li class="level3"><a href="#autotoc_md1134">Validate impact of your work</a></li>
<li class="level3"><a href="#autotoc_md1135">Tweak your C++ code</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This page describes how you introduce a new solver. New solver here means that you introduce a new particle species - likely with some bespoke numerics, runtime behaviour or physics. Therefore, introducing a new solver comes along in three flavours:</p>
<ol type="1">
<li>You might arrange existing Swift kernels into a new particle type;</li>
<li>You might introduce totally new physics;</li>
<li>You might tune a certain numerical particle species to yield better performance.</li>
</ol>
<p>Higher-level performance optimisation is discussed on its <a class="el" href="../../d3/dc8/page_swift_performance_optimisation.html">dedicated page</a>. This page focuses on the particle view.</p>
<h1><a class="anchor" id="autotoc_md1117"></a>
Introduce a new particle type</h1>
<p>Particles are characterized by their attributes (position, velocity, density, ...), their behaviour in the simulation and their initialisation. The latter two are formalised by the particle's algorithmic steps. You can think of them as a sequence of operations which have to performed per particle per time step or until we have a properly initialised particle. You can visualise a particle's algorithm via a simple graph:</p>
<div class="image">
<img src="../../particle-lifecycle.png" alt="" width="50%"/>
<div class="caption">
A typical life cycle of a particle for SPH with a kick-drift-kick time integration scheme</div></div>
<p>It illustrates that we have some attributes on a particle (left top). Each particle runs through a number of steps (right): We start with an initialisation (red) in which we throw the particles into the domain. After that, each particle runs through two initialisation steps. The latter one migth repeat. Per time step, each particle runs through six compute steps, while, once again, one of them might have to be repeated. Some computational steps might only act on one particle at a time, other steps might require the particles around a particle to compute an outcome (darker boxes).</p>
<p>This input sequence is taken as by our graph compiler to map it onto traversals of the data and to generate the C++ application. Details are discussed in <a class="el" href="../../da/d44/swift_graph_compiler.html">the section on the Swift Graph Compiler</a>. The basic rationale behind this design is that a particle-based algorithm is besed phrased as flow chart over a single particle. It is then the job of our software to bring this information together with the mesh in which the particles are organised, to map the updates onto data traversals, and to decide which particle to update at which point. By abstracting the mesh traversal away from the particle lifecycle, we can also easily handle multiple particle species. The particle lifecycle however encodes the required comptuational steps. Therefore, it comprises both the physics and the time stepping scheme. Both are intertwined in classic SPH.</p>
<p><a class="el" href="../../db/d37/structAny.html">Any</a> new particle type should be a subtype of <a class="el" href="../../d0/daf/namespaceswift2_1_1particle_1_1Particle.html">swift2.particle.Particle</a>.</p>
<h2><a class="anchor" id="autotoc_md1118"></a>
Declaring particle attributes</h2>
<p>You can instantiate your particle of interest and add further attributes to it in your main script. Alternatively, you might want to inherit from the particle type of interest and add additional attributes in the inherited type. Once you have called the superclass constructor, you can add further attributes to your species with instruction similar to</p>
<div class="fragment"><div class="line">self.f = <a class="code hl_namespace" href="../../d6/d7b/namespacedastgen2.html">dastgen2</a>.<a class="code hl_namespace" href="../../d6/ddd/namespacedastgen2_1_1attributes.html">attributes</a>.<a class="code hl_namespace" href="../../d7/d6e/namespacedastgen2_1_1attributes_1_1Double.html">Double</a>(<span class="stringliteral">&quot;f&quot;</span>)</div>
<div class="line">self.data.add_attribute(self.f)</div>
<div class="ttc" id="anamespacedastgen2_1_1attributes_1_1Double_html"><div class="ttname"><a href="../../d7/d6e/namespacedastgen2_1_1attributes_1_1Double.html">dastgen2.attributes.Double</a></div><div class="ttdef"><b>Definition</b> <a href="../../da/df9/Double_8py_source.html#l00001">Double.py:1</a></div></div>
<div class="ttc" id="anamespacedastgen2_1_1attributes_html"><div class="ttname"><a href="../../d6/ddd/namespacedastgen2_1_1attributes.html">dastgen2.attributes</a></div><div class="ttdef"><b>Definition</b> <a href="../../d8/d78/python_2dastgen2_2attributes_2____init_____8py_source.html#l00001">__init__.py:1</a></div></div>
<div class="ttc" id="anamespacedastgen2_html"><div class="ttname"><a href="../../d6/d7b/namespacedastgen2.html">dastgen2</a></div><div class="ttdef"><b>Definition</b> <a href="../../df/dd5/python_2dastgen2_2____init_____8py_source.html#l00001">__init__.py:1</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1119"></a>
The algorithmic steps for the particle life cycle</h2>
<p>The second essential ingredient to build a particle life cycle is to specify the sequence of algorithmic steps. Each particle has to have a routine <code>algorithm_steps()</code> which returns the sequence of algorithmic steps to be run per time step. The individual algorithm steps are instances of AlgorithmStep (<code><a class="el" href="../../d5/d48/AlgorithmStep_8py.html">python/swift2/particle/AlgorithmStep.py</a></code>) As an example, we discuss the SPH density loop:</p>
<div class="fragment"><div class="line">AlgorithmStep(</div>
<div class="line">  name                           = <span class="stringliteral">&quot;DensityLoopWithConstantSmoothingLength&quot;</span>,</div>
<div class="line">  dependencies                   = AlgorithmStep.Dependencies.NEIGHBOURS,</div>
<div class="line">  effect                         = AlgorithmStep.Effect.ALTER_LOCAL_STATE,</div>
<div class="line">  touch_vertex_first_time_kernel = <span class="stringliteral">&quot;&quot;</span><span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">      touch_vertex_first_time_kernel=&quot;</span>::swift2::forAllParticles(assignedParticles, ::swift2::kernelPlaceholders::hydro_prepare_density&lt;globaldata::{}&gt; );<span class="stringliteral">&quot;.format(self.name),</span></div>
<div class="line"><span class="stringliteral">                                   &quot;</span><span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line"> </div>
<div class="line">  cell_kernel                    = <span class="stringliteral">&quot;&quot;</span><span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">                                   ::swift2::kernels::computeDensity(</span></div>
<div class="line"><span class="stringliteral">                                     localParticles,</span></div>
<div class="line"><span class="stringliteral">                                     activeParticles,</span></div>
<div class="line"><span class="stringliteral">                                     {}</span></div>
<div class="line"><span class="stringliteral">                                   );</span></div>
<div class="line"><span class="stringliteral">                                   &quot;</span><span class="stringliteral">&quot;&quot;</span>.format(self._hydroDimensions),</div>
<div class="line"> </div>
<div class="line">  touch_vertex_last_time_kernel  = <span class="stringliteral">&quot;&quot;</span><span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">                                   ::swift2::kernels::endDensityCalculationWithConstantSmoothingLength(</span></div>
<div class="line"><span class="stringliteral">                                       localParticles,</span></div>
<div class="line"><span class="stringliteral">                                       {},</span></div>
<div class="line"><span class="stringliteral">                                       {},</span></div>
<div class="line"><span class="stringliteral">                                       {}</span></div>
<div class="line"><span class="stringliteral">                                       );</span></div>
<div class="line"><span class="stringliteral">                                   &quot;</span><span class="stringliteral">&quot;&quot;</span>.format(self._hydroDimensions,</div>
<div class="line">                                              self._eta_factor,</div>
<div class="line">                                              self._alpha_av),</div>
<div class="line"> </div>
<div class="line">  includes                       = <span class="stringliteral">&quot;&quot;</span><span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">                                   #include &quot;</span>Constants.h<span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">                                   #include &quot;</span><a class="code hl_namespace" href="../../de/dac/namespaceswift2.html">swift2</a>/<a class="code hl_namespace" href="../../de/dd9/namespacekernels.html">kernels</a>/ParticleParticleInteraction.h<span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">                                   #include &quot;</span><a class="code hl_namespace" href="../../de/dac/namespaceswift2.html">swift2</a>/<a class="code hl_namespace" href="../../de/dd9/namespacekernels.html">kernels</a>/ParticleSelfInteraction.h<span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">                                   #include &quot;</span><a class="code hl_namespace" href="../../de/dac/namespaceswift2.html">swift2</a>/<a class="code hl_namespace" href="../../de/dd9/namespacekernels.html">kernels</a>/kernel_hydro.h<span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">                                   #include &quot;</span><a class="code hl_namespace" href="../../de/dac/namespaceswift2.html">swift2</a>/<a class="code hl_namespace" href="../../de/dd9/namespacekernels.html">kernels</a>/equation_of_state.h<span class="stringliteral">&quot;</span></div>
<div class="line"><span class="stringliteral">                                   &quot;</span><span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">)</div>
<div class="ttc" id="anamespacekernels_html"><div class="ttname"><a href="../../de/dd9/namespacekernels.html">kernels</a></div><div class="ttdef"><b>Definition</b> <a href="../../d0/db5/idx_8h_source.html#l00005">idx.h:5</a></div></div>
<div class="ttc" id="anamespaceswift2_html"><div class="ttname"><a href="../../de/dac/namespaceswift2.html">swift2</a></div><div class="ttdoc">This file is part of the SWIFT 2 project.</div><div class="ttdef"><b>Definition</b> <a href="../../da/d65/FixedBoundary_8h_source.html#l00008">FixedBoundary.h:8</a></div></div>
</div><!-- fragment --><ul>
<li>The algorithmic step has a unique name.</li>
<li><code>dependencies</code> can distinguish between two options: <code>NEIGHBOURS</code> and <code>SELF</code>. These refer to the two type of operations that are done in the SPH context: either the computation depends on the particle itself or it requires contributions from neighbours.</li>
<li><code>effect</code> has different options depending on the output type of the calculation, e.g. <code>ALTER_LOCAL_STATE</code> means that only the current particle is updated. Other options notably include changes of the position or cut-off radius or also the possibility that the code asks Peano to rerun this step.</li>
<li><code>cell_kernel</code> invokes a compute kernel which depends on the <code>localParticles</code> and <code>activeParticles</code> sets of the PIDT scheme.</li>
<li><code>touch_vertex_first_time_kernel</code> invokes a compute kernel which depends exclusively on the <code>localParticles</code> set of the PIDT scheme when the particle is first &lsquo;touched&rsquo; during the mesh traversal.</li>
<li><code>touch_vertex_last_time_kernel</code> analogous to the previous one.</li>
<li><code>includes</code> allows us to ensure that the kernels that we invoke are well-known.</li>
<li>You can inform Swift about dependency invariants such as <div class="fragment"><div class="line">touch_vertex_first_time_dependency_policy=<span class="stringliteral">&quot;TouchAtLeastOnce_AllPreviousStepsUpdateAtLeastOnce_MayOverwritePreviousCellUpdatesFromSameSweep&quot;</span>,</div>
<div class="line">cell_kernel_dependency_policy=<span class="stringliteral">&quot;TouchAtLeastOnce_AllPreviousStepsUpdateAtLeastOnce_MayOverwritePreviousCellUpdatesFromSameSweep&quot;</span>,</div>
</div><!-- fragment --> In non-release builds, these will be checked at runtime.</li>
</ul>
<p>The full life cycle is just a list of such an algorithmic steps. A very simple case of such a class can be found in <a class="el" href="../../de/d88/namespaceswift2_1_1particle_1_1ExplicitEulerDynamicSearchRadius.html">swift2.particle.ExplicitEulerDynamicSearchRadius</a>. Here, the two key routines simply create a new sequence of <a class="el" href="../../d7/d0c/namespaceswift2_1_1particle_1_1AlgorithmStep.html">swift2.particle.AlgorithmStep</a> in the two core routines. You might want to study <a class="el" href="../../d3/d4b/namespaceswift2_1_1particle_1_1SPHLeapfrogFixedSearchRadius.html">swift2.particle.SPHLeapfrogFixedSearchRadius</a>, which is more sophisticated. It first creates a dictionary of elementary steps and lets algorithm_steps() and initialisation_steps() then "assemble" the particle flow from this dictionary.</p>
<h3><a class="anchor" id="Section_SwiftAlgorithmStepsInitialization"></a>
The algorithmic steps for the particle initialisation</h3>
<p>This is very similar to the algorithmic steps. Each particle offers a routine initialisation_steps() which returns a sequence of steps that have to be called before we start the actual simulation. The sequence can be empty. The graph compiler nevertheless will ensure that the initial sorting of the particles is correct.</p>
<h3><a class="anchor" id="autotoc_md1120"></a>
Remarks on particular particle update steps</h3>
<h4><a class="anchor" id="autotoc_md1121"></a>
Drifts (movements)</h4>
<p>Movements and changes to the paticle cut-offs should, in line with the <a class="el" href="../../db/d91/page_toolbox_particles_mesh_consistency.html">discussion in Peano's toolbox</a>, only be done in touchVertexLastTime(). That is, usually the movement delta is accumulated over the mesh traversal and then applied in this last access step. From hereon, it is Peano's responsibility to get the particle to the right position in space in time for the next mesh sweep.</p>
<h4><a class="anchor" id="autotoc_md1122"></a>
Interaction range calculation</h4>
<p>There are multiple flavours of the computation of the particle interaction radius stemming from the density reconstruction:</p>
<ol type="1">
<li>Invariant smoothing length;</li>
<li>Adaptive smoothing length within the constraints of a given upper bound (cut-off radius);</li>
<li>Adaptive smoothing length without constraints.</li>
</ol>
<p>The first variant is simple: We have to ensure in the particle initialisation that the cut-off radius is bigger or equal to the fixed smoothing length. As the cut-off determines the distance in which Peano searches for neighbouring particles, we will then get a set of active particles per local particle, iterate through them, and neglect all particles that are not within the smoothing length:</p>
<ul>
<li>The algorithm step's swift2.particle.AlgorithmStep.Dependencies is set to NEIGHBOURS.</li>
<li>The algorithm step's swift2.particle.AlgorithmStep.Effect is set to ALTER_LOCAL_STATE.</li>
</ul>
<p>The second variant can change the local state. It's</p>
<ul>
<li>swift2.particle.AlgorithmStep.Dependencies is set to NEIGHBOURS;</li>
<li>swift2.particle.AlgorithmStep.Effect is set to ALTER_LOCAL_STATE_AND_MIGHT_RERUN.</li>
</ul>
<p>Consult the discussion of multiscale interactions below to understand why it might happen that this algorithm reruns. The third, most flexible, variant is configured with</p>
<ul>
<li>swift2.particle.AlgorithmStep.Dependencies is set to NEIGHBOURS;</li>
<li>swift2.particle.AlgorithmStep.Effect is set to CHANGE_POSITION_OR_INTERACTION_RADIUS_AND_MIGHT_RERUN.</li>
</ul>
<h4><a class="anchor" id="autotoc_md1123"></a>
Multiscale interactions</h4>
<p>If particles interact with particles, we have to keep in mind that these are realised through computations between the local set and the active set. The recursive definition of the <a class="el" href="../../d6/de2/page_toolbox_particles_mesh_traversal.html">active set</a> implies that the active set exclusively hosts particles of the same mesh resolution plus the ones stemming from coarser levels. We miss out on particles which are stored on finer levels.</p>
<p>This is not only a constraint for setups with largely varying smoothing lengths. It already becomes a serious issue if you employ adaptive grids. The action set <a class="el" href="../../db/de5/namespacepeano4_1_1toolbox_1_1particles_1_1api_1_1AbstractUpdateParticleGridAssociation.html">peano4.toolbox.particles.api.AbstractUpdateParticleGridAssociation</a> discusses this phenomenon in detail.</p>
<p>The solution to this "problem" is to accumulate all data (including the density) and to make (local) particles add contributions to active particles on coarser levels. Usually, i.e. on a single level, active particles act on local levels but are not updated themselves. So we</p>
<ul>
<li>reset the particle state in touchVertexFirstTime();</li>
<li>accumulate data within the cell kernels;</li>
<li>update the state in touchVertexLastTime().</li>
</ul>
<p>If the calculation of a particle state is itself an iterative scheme, we have to map the iterations onto mesh sweep reruns: In Peano, we never have the whole set of neighbouring particles available! Rerunning a step is triggered through the particle's species: The code has to invoke its setRerunPreviousGridSweep().</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000088">Todo</a></b></dt><dd>Conflict of concurrent data access is here, but it is not really a conflict. It is a simple critical section.</dd></dl>
<h4><a class="anchor" id="autotoc_md1124"></a>
Reruns of steps</h4>
<p>If you want to specify an algorithm step that is maybe rerun (as you alter the search radius, e.g., or implement an iterative scheme), you can trigger such a rerun through the species. The idea is as follows:</p>
<ol type="1">
<li>You plug into the step's preparation, and you invoke clearRerunPreviousGridSweepFlag() on the species.</li>
<li>At any point where you decide to rerun throughout the step, i.e. in any event, you can grab the particle's species and invoke setRerunPreviousGridSweep().</li>
</ol>
<p>The clss <a class="el" href="../../da/d50/classswift2_1_1ParticleSpecies.html" title="Represent one type (species) of particles.">swift2::ParticleSpecies</a> provides further details. However, the user is usually only handling those to core operations. All global reductions, i.e. synchronisation of ranks, and the actual reruns are then championed by the Swift/Peano framework.</p>
<h4><a class="anchor" id="autotoc_md1125"></a>
Iterators</h4>
<p>Swift phrases its physics in particle-to-particle interactions (see remarks below). You map these onto sets of particles via functions such as swift2::forAllParticles(). These functions are written down as templates. We refer to them as iterators.</p>
<p>Most particle kernels or particle-particle kernels are templates, too. The combination/nesting of two templates becomes tricky. While sophisticated template meta programming can resolve this, it makes sense to specialise the kernels explicitly. We do so through the format() call above.</p>
<h1><a class="anchor" id="autotoc_md1126"></a>
New solver kernels (physics)</h1>
<p>Swift's core philosophy is that users should take care of only three things (most of the time):</p>
<ul>
<li>Specify initial and boundary conditions;</li>
<li>Model the lifecycle of the individual particle species;</li>
<li>Specify the physics through particle-particle (1:1) compute kernels.</li>
</ul>
<p>In line with this philosophy, new physics are primarily introduced by adding new particle-particle interaction routines: They take a local particle (to be modified) and an active particle (acting on the local one) and upate the former. This is a binary compute kernel. We also have unary compute kernels which only take one single particle and update it. Our goal is to come up with an SPH formalism, where physical aspects are decoupled from data management, HPC, orchestration, ... challenges where possible.</p>
<p>To make this work, all particle-update kernels and particle-particle kernels have to commit to a few basic conventions:</p>
<ol type="1">
<li>They accept three arguments: The local particle, an active particle, and a vertex or cell marker. The second argument is not required for an unary kernel.</li>
<li>They internally check that the two particles are not the same. If so, they do not alter the particle. That is, self-action is avoided within the compute kernel itself. This item obviously is irrelevant for unary kernels.</li>
<li>The kernel internally checks if a particle has to be updated. For a vertex kernel (unary), it should check that the particle has not been moved meanwhile and hence is updated twice. For a cell (binary) kernel, it should check that the particle resides within the cell of interest. For both checks, Swift provides the generic check routines localParticleCanBeUpdatedInVertexKernel() and localParticleCanBeUpdatedInCellKernelFromAnyOtherParticle() which usually serve the needs.</li>
<li>Kernels can be either void or return a value. However, any assumption that some data is to be (globally) reduced has to be documented explicitly, and it will become the responsibility of the user to care for this reduction. Alternatively, kernels can obviously reduce internally into their species, e.g.</li>
</ol>
<p>Most kernels are templates parameterised over the particle type. However, there might be cases where you have bespoke kernels that apply only to one single species. The punchline to take away is that it is the kernel's responsibility to ensure that any particle update is rightfully performed.</p>
<p>To make both the tuning and the validation of the kernel easier, it is very important that the kernel's documentation explicitly enlists its constraints and also the checks used internally. Such information can later on be used within the algorithm steps (see remark above on invariants) and performance engineers (see remarks below).</p>
<h1><a class="anchor" id="autotoc_md1127"></a>
Cut-off radius realisation (e.g. in the force calculation)</h1>
<p>Swift 2 builds up its interaction lists (who has to be checked against whom) on-the-fly while it runs through the mesh. Hereby, it employs the concept of a <a class="el" href="../../d6/de2/page_toolbox_particles_mesh_traversal.html">search radius</a>: Only particles within the the search radius of a particle \( p_i \) are taken into account when we search for any other particle \( p_j \) interacting.</p>
<p>In Swift, the search radius \( r_{\text{search}} \) is a <em><b>technical quantity</b></em> (See also <a class="el" href="../../de/d8e/swift_terminology.html">Terminology</a>). The physics are not directly impacted by it. They are determined by the smoothing length \(
r_{\text{smooth}} \) which changes (more) frequently. The smoothing length directly determines the interaction radius \(r_{\text{iact}} \):</p>
<p>\(r_{\text{iact}} = \gamma_{\text{kernel}} r_{\text{smooth}}\)</p>
<p>where \(\gamma_{\text{kernel}}\) is a constant which depends on the spatial dimensionality and the SPH kernel used (see <a class="el" href="../../de/d8e/swift_terminology.html">Terminology</a> and <a href="https://arxiv.org/abs/1204.2471">Dehnen &amp; Aly 2012</a> ). Its numerical value is \(\sim 2\).</p>
<p>Naturally, we must ensure that the search radius is always equal or greater than the interaction radius.</p>
<p>Our code runs through the mesh and looks at all particles around a particle within the search radius. <b>It is important to note that we have different types of interactions in our loops.</b> For the density calculation, all particles within the interaction radius then enter the equations. We interact a particle i with a particle j if:</p>
<p>\(
 |x(p_i) - x(p_j)| \leq r_{\text{iact}}(p_i).
\)</p>
<p>For the force calculation however, we have a symmetric correlation: Two particles interact if:</p>
<p>\(
 |x(p_i) - x(p_j)| \leq r_{\text{iact}}(p_i)
 \wedge
 |x(p_j) - x(p_i)| \leq r_{\text{iact}}(p_j).
\)</p>
<p>Without the or, we could end up with non-symmetric forces.</p>
<div style="background-color: #fcc ; padding: 10px; border: 1px solid green;"> Due to the symmetry the force calculation, the smoothing length has to be at most \( 1/\gamma_{\text{kernel}} \approx 1/2\) of the search radius. Otherwise, we miss out on particles. </div><div class="image">
<img src="../../algorithm-search-radius.png" alt=""/>
</div>
<p>The illustration above shows what can be wrong if the constraint</p>
<p>\(
\gamma_{\text{kernel}} r_{\text{smooth}}(p_i) = r_{\text{iact}}(p_i) \leq
 r_{\text{search}}(p_i)
\)</p>
<p>is violated: The red particle has to be updated within the middle cell. Let its search radius be depicted with the dotted circle, and the actual interaction radius with a solid one. As we store particles next to their closest vertex, we effectively can compare the red particle against all particles that are stored within the dashed square: We test all particles within the cell plus a h/2 halo. This is in line with <a class="el" href="../../d6/de2/page_toolbox_particles_mesh_traversal.html">Peano's search radius and sorting</a> definition.</p>
<p>Consequently, we compare red with green and find out that (a) their search radius overlaps, and (b) their interaction radius doesn't. So we ignore the interaction. Red and blue are never even compared.</p>
<p>Now assume the smoothing length grows, increasing the interaction radius, such that it now becomes almost the search radius (dotted circle). Now, green is still within the interaction radius of red, so nothing has changed here. Blue however now ends up within the search radius of red, yet is not taken into account as it is stored within a vertex that is not adjacent to the current cell. We miss out on this iteration.</p>
<h1><a class="anchor" id="autotoc_md1128"></a>
Tune a kernel realisation</h1>
<p>Swift 2 codes can be tuned in many ways. First, users can tune their code by picking an optimising <a class="el" href="../../da/d44/swift_graph_compiler.html">graph compiler</a>. They can also tweak the memory layout as discussed on <a class="el" href="../../d3/dc8/page_swift_performance_optimisation.html">Performance optimisation</a>. On this page, we discuss how we can optimise the particle's compute kernels themselves. Before you continue to read, please consult <a class="el" href="../../d0/dd8/swift_runtime_analysis.html">Swift's page on runtime analysis</a>, too, so all follow-up steps can be supported with appropriate measurements.</p>
<h2><a class="anchor" id="autotoc_md1129"></a>
Move checks out of the kernels</h2>
<p>Users typically start from a generic usage of the iterators in ParticleSetIterators.h. That is, they simply type down <a class="el" href="../../de/dd5/namespaceswift2_1_1kernels.html#a4a01b24be4280fa19dc241e466cdaf76" title="Run over all local particle-active particle combinations.">swift2::kernels::forAllParticlePairs()</a> and hand in their compute kernels of choice. Most kernels check internally if they are supposed to run or not (consult <a class="el" href="../../d2/daf/swift_particle_new_solver.html">how to introduce a new solver</a>). All these iterators do therefore is to invoke the actual kernel per particle or particle pair, respectively.</p>
<p>However, it might make sense to evaluate a "shall I run" predicate ahead of the actual kernel invocation: If a particle is outside of a cell in a cell kernel, it might be reasonable not even to start to run over all the (active) particles around it. So this additional check makes mainly sense for particle-particle interactions, i.e. forAllParticlePairs(), but Swift 2 realises the same guard mechanism for both forAllParticles() and forAllParticlePairs(). Both routines do accept additional guards which allow you to mask out certain calculations a priori.</p>
<p>If kernels consume a lot of compute time, it might be reasonable to check a priori if it makes sense to involve a kernel at all. This again can be done by passing another guard into the iterator. Replace</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="../../de/dd5/namespaceswift2_1_1kernels.html#a4a01b24be4280fa19dc241e466cdaf76">::swift2::kernels::forAllParticlePairs</a>( cellMarker, ..., ::swift2::kernels::legacy::densityKernel&lt;globaldata::HydroPart&gt;, ::swift2::kernels::alwaysUpdateInCellKernel&lt;globaldata::HydroPart&gt;, ::swift2::kernels::localParticleCanBeUpdatedInCellKernelFromAnyOtherParticle&lt;globaldata::HydroPart&gt;);</div>
<div class="ttc" id="anamespaceswift2_1_1kernels_html_a4a01b24be4280fa19dc241e466cdaf76"><div class="ttname"><a href="../../de/dd5/namespaceswift2_1_1kernels.html#a4a01b24be4280fa19dc241e466cdaf76">swift2::kernels::forAllParticlePairs</a></div><div class="ttdeci">void forAllParticlePairs(const swift2::CellMetaData &amp;cellMetaData, LocalParticleContainer &amp;localParticles, ActiveParticleContainer &amp;activeParticles, ParticleBinaryOperator&lt; PCParticle&lt; LocalParticleContainer &gt;, PCParticle&lt; ActiveParticleContainer &gt; &gt; auto f, UpdateParticleAssignedToCellPredicate&lt; PCParticle&lt; LocalParticleContainer &gt; &gt; localParticlePredicate=::swift2::kernels::localParticleCanBeUpdatedInCellKernel&lt; PCParticle&lt; LocalParticleContainer &gt; &gt;, UpdateParticlePairWithinCellPredicate&lt; PCParticle&lt; LocalParticleContainer &gt; &gt; particlePairPredicate=::swift2::kernels::localParticleCanBeUpdatedInCellKernelFromAnyOtherParticle&lt; PCParticle&lt; LocalParticleContainer &gt; &gt;)</div><div class="ttdoc">Run over all local particle-active particle combinations.</div><div class="ttdef"><b>Definition</b> <a href="../../dc/db7/ParticleSetIterators_8cpph_source.html#l00043">ParticleSetIterators.cpph:43</a></div></div>
</div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="../../de/dd5/namespaceswift2_1_1kernels.html#a4a01b24be4280fa19dc241e466cdaf76">::swift2::kernels::forAllParticlePairs</a>( cellMarker, ..., ::swift2::kernels::legacy::densityKernel&lt;globaldata::HydroPart&gt;, ::swift2::kernels::localParticleCanBeUpdatedInCellKernel&lt;globaldata::HydroPart&gt;, ::swift2::kernels::legacy::densityKernelPairEvaluationPredicate&lt;globaldata::HydroPart&gt;);</div>
</div><!-- fragment --><p>So far, this does actually decrease the performance, as you evaluate predicates now twice. To remove the redundancy, you have to provide a second variant of the compute kernel without these internal checks:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="../../de/dd5/namespaceswift2_1_1kernels.html#a4a01b24be4280fa19dc241e466cdaf76">::swift2::kernels::forAllParticlePairs</a>( cellMarker, ..., ::swift2::kernels::legacy::densityKernelWithoutChecks&lt;globaldata::HydroPart&gt;, ::swift2::kernels::localParticleCanBeUpdatedInCellKernel&lt;globaldata::HydroPart&gt;, ::swift2::kernels::legacy::densityKernelPairEvaluationPredicate&lt;globaldata::HydroPart&gt;);</div>
</div><!-- fragment --><div style="background-color: #cfc ; padding: 10px; border: 1px solid green;"> If often start with kernels similar to densityKernelWithoutChecks() and add in their documentation with which predicate they have to be combined. So I write in the docu "please use ::swift2::kernels::localParticleCanBeUpdatedInCellKernel() with it". After that, I write a second routine densityKernel() which really just evaluates this predicate as recommended and then forwards the call to densityKernelWithoutChecks(). </div><p>If you have a rather complicated logic, such as</p>
<ul>
<li>particle has to be local,</li>
<li>particle has to be within a certain reach of another particle, and</li>
<li>particle has to have a certain boolean flag,</li>
</ul>
<p>then I typically write a bespoke predicate only for this particular case. ::swift2::kernels::legacy::densityKernelPairEvaluationPredicate() is a nice example of such a kernel-specific predicate.</p>
<h2><a class="anchor" id="autotoc_md1130"></a>
Step 2: Switch to a bespoke iterator</h2>
<p>The standard iterators <a class="el" href="../../de/dd5/namespaceswift2_1_1kernels.html#aa3306a2f1990ecab382f7f1565897ece" title="Run over all particles and update them independent of each other.">swift2::kernels::forAllParticles()</a> and <a class="el" href="../../de/dd5/namespaceswift2_1_1kernels.html#a4a01b24be4280fa19dc241e466cdaf76" title="Run over all local particle-active particle combinations.">swift2::kernels::forAllParticlePairs()</a> do not exploit any information about the data layout. Once you have <a class="el" href="../../d3/dc8/page_swift_performance_optimisation.html">tweaked your data layout to ensure that you have coalesced (continuous) particle data</a>, it is therefore a natural next step to switch to an iterator that exploits this knowledge.</p>
<p>The clean way to do this is to replace your <a class="el" href="../../de/dd5/namespaceswift2_1_1kernels.html#a4a01b24be4280fa19dc241e466cdaf76" title="Run over all local particle-active particle combinations.">swift2::kernels::forAllParticlePairs()</a> calls with <a class="el" href="../../d7/da3/namespaceswift2_1_1kernels_1_1coalesced.html#a157d932934a75a454149163a91785945" title="Simple vectorised version of pair-wise comparison.">swift2::kernels::coalesced::forAllParticlePairs()</a> or other variants. There are several ones available. Each one might be particular useful for one kernel-particle combination and make the performance break down for the next one.</p>
<p>If you don't want to run through your particle step by step, you can use the particle's routine swift2.particle.SPHParticle.switch_namespace_of_all_particle_iterators() to switch the namespace of all iterators. This is the brute-force variant which overwrites all particle-specific tuning (and might break down for particle types that do not stick exactly to all default naming conventions).</p>
<h2><a class="anchor" id="autotoc_md1131"></a>
Step X: Port kernels to GPUs</h2>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000089">Todo</a></b></dt><dd>Yet to be written, but, in principle, it is just a switch to another iterator.</dd></dl>
<h2><a class="anchor" id="autotoc_md1132"></a>
Troubleshooting: The kernel does not vectorise despite all these steps</h2>
<h3><a class="anchor" id="autotoc_md1133"></a>
Expose all particle attributes</h3>
<p>Vectorisation requires very aggressive inlining. To facilitate such inlining, all the setters and getters of particle attributes have to be available in the header. Study the <a class="el" href="../../dd/db7/page_dastgen_home.html">DaStGen documentation</a> for remarks how to move getters and settings into the header. Notably study the semantics of the function</p>
<div class="fragment"><div class="line">particle.data.expose_all_attributes_in_header_file()</div>
</div><!-- fragment --><p>which moves all attribute setters and getters into the header and hence facilitiates very aggressive inlining via copy n paste.</p>
<h3><a class="anchor" id="autotoc_md1134"></a>
Validate impact of your work</h3>
<p>LLVM-based compilers provide ample feedback on your vectorisation once you add the compile flags</p>
<div class="fragment"><div class="line">-Rpass=loop-vectorize -Rpass-missed=loop-vectorize -Rpass-analysis=loop-vectorize</div>
</div><!-- fragment --><p>Every <a class="el" href="../../d1/df8/namespacepeano4_1_1Project.html">peano4.Project</a> holds an attribute called makefile of the type <a class="el" href="../../d8/d9a/namespacepeano4_1_1output_1_1Makefile.html">peano4.output.Makefile</a>. You can add additional compiler flags like these three guys there. Alternatively, you can reconfigure/rerun CMake on the whole project, but that means that you get vectorisation reports for every single file in Peano. As any Peano extension picks up the makefile settings from the core library you will get vectorisation reports for your particular SPH code, too.</p>
<p>For fully vectorised kernels, the reported width will always match the machine width (4 for AVX2 and 8 for AVX512 capable machines and double precision kernels). Sometimes, the compiler decides against vectorisation:</p>
<div class="fragment"><div class="line">../../src/<a class="code hl_namespace" href="../../de/dac/namespaceswift2.html">swift2</a>/<a class="code hl_namespace" href="../../de/dd9/namespacekernels.html">kernels</a>/ParticleParticleInteraction.cpph:369:13: remark: Disabling scalable vectorization, because target does not support scalable vectors. [-Rpass-analysis=loop-vectorize]</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> activeParticleNumberInThisChunk = 0; activeParticleNumberInThisChunk &lt; activeParticlesChunkSize;</div>
<div class="line">            ^</div>
<div class="line">../../../../src/<a class="code hl_namespace" href="../../de/dac/namespaceswift2.html">swift2</a>/<a class="code hl_namespace" href="../../de/dd9/namespacekernels.html">kernels</a>/ParticleParticleInteraction.cpph:369:13: remark: the cost-model indicates that interleaving is not beneficial [-Rpass-analysis=loop-vectorize]</div>
<div class="line">../../../../src/<a class="code hl_namespace" href="../../de/dac/namespaceswift2.html">swift2</a>/<a class="code hl_namespace" href="../../de/dd9/namespacekernels.html">kernels</a>/ParticleParticleInteraction.cpph:369:13: remark: vectorized loop (vectorization width: 8, interleaved count: 1) [-Rpass=loop-vectorize]</div>
</div><!-- fragment --><p>In this case, it might make sense to overwrite the compiler heuristics. Consult your compiler handbook. Again, it might be inconvenient to do this for the whole code. Instead, you might want to do it only for one object file. Follow the same pattern as introduced above for the optimisation report.</p>
<p>Unfortunately, Swift/Peano has currently no feature to pick compiler arguments manually per file. Worse, the Python API overwrite the Makefile. It might make sense to design a proper makefile manually and then to disable the overwriting in the Peano 4 project that is produced by Swift's Python API.</p>
<div style="background-color: #fcc ; padding: 10px; border: 1px solid green;"> We ran sometimes into issues when we studied the success of our vectorisation "only" via performance analysis tools such as Advisor or MAQAO. The tools showed that we use vectorisation. Still, the code remained slow. In many of these cases, the compiler failed to vectorise over multiple particles but was successful in vectorising some subcalculations per particle. The resulting code then contained AVX instructions, and the tool reported "successfully vectorised" which is not what we wanted. It is important to study the actual compiler feedback. </div><h3><a class="anchor" id="autotoc_md1135"></a>
Tweak your C++ code</h3>
<p>We've started to collect a list of todos and no-goes for the vectorisation below. You might want to weak this in one way or the other and it will be incomplete. But it is a reasonable starting point:</p>
<ul>
<li>The compiler has to be able to inline. According to <a href="https://clang.llvm.org/docs/AttributeReference.html#always-inline-force-inline">https://clang.llvm.org/docs/AttributeReference.html#always-inline-force-inline</a> this is something one should be able to control via the annotation <pre class="fragment">    [[clang::always_inline]]
</pre> but this led to multiple compiler crashes (again with Intel). To some degree this makes sense: The function has to be in the header! I played around with ipo, but that did not resolve the fundamental issues. So you have to put everything used in the for loops into headers.</li>
<li>You might have to recursively study all inlined methods and make the stuff they use inline as well.</li>
<li>Big if branches are challenging for the vectoriser. Hence, I compute one scalar which is either set to 1.0 if we should update and otherwise 0.0. By multiplying all updates with this scalar, we can effectively mask out the kernel or keep its action. This works as long as all updates are additive, i.e. we take the existing value and add something onto it, though some slight tweaking also makes it work with the max and min function.</li>
<li>The <a class="el" href="../../d2/d45/namespacetarch_1_1la.html" title="My collection of tiny vector operations.">tarch::la</a> macros like smaller() or smallerEquals() might stop the vectorisation. In this case, you have to move the implementations into the header. We don't move all linear algebra routines into the header, as this would blow up the executable size. For this particular kernel, we have moved the required routines already.</li>
<li><p class="startli">It seemed originally that one has to replace the std::pow function with a specialised version that takes into account that the power is an integer. The C++ standard <a href="https://en.cppreference.com/w/cpp/numeric/math/pow">https://en.cppreference.com/w/cpp/numeric/math/pow</a> is not clear if there is still a specialised version of pow for integers. However, all seems to vectorise nicely even if we use the power with the Intel 2023.2 compiler.</p>
<p class="startli">Along the same lines, we sometimes encouter issues with the max and min function. While replacing it with a manual case distinction</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> value = newValue &gt; value : newValue : value;</div>
</div><!-- fragment --><p class="startli">might help for some compilers, it is usually a bad idea and leads to error reports due to dependencies. We found it more convenient to work with the actual C++ max function. In this case, the vectorisation however works if and only if we translate with -Ofast or -ffast-math!</p>
</li>
<li><p class="startli">Complex statements such as</p>
<div class="fragment"><div class="line"><span class="comment">// Update the signal velocity</span></div>
<div class="line">localParticle-&gt;setV_sig_AV(std::max(localParticle-&gt;getV_sig_AV(), mask * <a class="code hl_variable" href="../../db/dba/hydro_8h.html#a597d0eb99c60b98bfa2d8e77d7715bec">v_sig</a>));</div>
<div class="ttc" id="ahydro_8h_html_a597d0eb99c60b98bfa2d8e77d7715bec"><div class="ttname"><a href="../../db/dba/hydro_8h.html#a597d0eb99c60b98bfa2d8e77d7715bec">v_sig</a></div><div class="ttdeci">p force v_sig</div><div class="ttdef"><b>Definition</b> <a href="../../db/dba/hydro_8h_source.html#l00379">hydro.h:379</a></div></div>
</div><!-- fragment --><p class="startli">break the vectorisation. But once you replace them with statements similar to</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> currentAV = localParticle-&gt;getV_sig_AV();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> biggerAV  = mask * <a class="code hl_variable" href="../../db/dba/hydro_8h.html#a597d0eb99c60b98bfa2d8e77d7715bec">v_sig</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> newAV     = biggerAV &gt; currentAV ? biggerAV : currentAV;</div>
<div class="line">localParticle-&gt;setV_sig_AV(newAV);</div>
</div><!-- fragment --><p class="startli">vectorisation seems to work. </p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d6/dba/page_swift2_home.html">Swift 2</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:06 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
