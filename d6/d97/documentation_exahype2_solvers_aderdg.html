<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d97/documentation_exahype2_solvers_aderdg.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ADER-DG solvers</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md904">Algorithmic blueprint of a two-sweep realisation</a><ul><li class="level3"><a href="#autotoc_md905">Alternatives</a></li>
<li class="level3"><a href="#autotoc_md906">Adaptive mesh refinement</a></li>
</ul>
</li>
</ul>
</ul>
</div>
<div class="textblock"><p>ADER-DG conceptually consists only of three steps: prediction, Riemann solve and correction. While this is conceptually simple, challenges arise once we consider dynamic AMR or local time stepping. This section discusses different ADER-DG implementation flavours. The flavours differ in the way they map the three core steps onto mesh traversals.</p>
<div class="image">
<img src="../../ADER-DG.png" alt=""/>
</div>
<p>It is important to reiterate the data dependencies and to introduce some intermediate steps which are required to couple the core algorithmic steps:</p>
<ul>
<li>The <em><b>prediction</b></em> uses the cell data and determines an (educated) solution guess over the cell in space and time. This is step (1) in the sketch above. We keep the guess at the terminal time and</li>
<li>we <em><b>project</b></em> both the space-time solution as well as the space-time fluxes within the cell onto the faces and onto the terminal time. The faces now hold an approximation of the values and fluxes at the terminal time.</li>
<li>We solve the <em><b>Riemann</b></em> problem on the faces using these projected values. This is step (2) from the sketch.</li>
<li>We <em><b>backproject</b></em> the solution of the Riemann solves into the spatial cell domain and compute its additional contribution on top of the guess for the final solution. For linear PDEs, this compute step simplifies, as we can integrate over the Riemann solutions first and then only project the final result in time on the face onto the final slab on the cell. There's no need to project back into a space-time volumetric representation first.</li>
<li>We <em><b>correct</b></em> the educated guess using the backprojected data and obtain a new solution. This is step (3) in the sketch above.</li>
</ul>
<p>To discuss the temporal logic of these steps, it is important to reiterate that Peano runs through the underlying spacetree in a top-down fashion and users can only plug into vertex, face and cell events. That is, we can never access the adjacent cells of a cell or a face, and we have no control over the order of the traversal. We only know that it follows these top-down/bottom-up constraints.</p>
<div class="image">
<img src="../../spacetree.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md904"></a>
Algorithmic blueprint of a two-sweep realisation</h2>
<p>As we distinguish plug-in points for cells from plug-in points (events tiggering actions) for faces, we can map a vanilla version of one ADER-DG step onto two mesh traversals:</p>
<ol type="1">
<li>Primary sweep<ol type="a">
<li>touchCellFirstTime(): Compute the predictor and project the predicted solution onto the face. This could alternatively also happen within touchCellLastTime(). As we usually work on the finest level, the last touch - which is the action when the tree traversal automaton backtracks - happens immediately after the first touch. In our code, the projection to the face is directly integrated with the predictor. This allows us not to have to store the entire space-time solution and to reuse the flux computations in the predictor for the projections, which means we both don't need to recompute the fluxes on the projected values and have more exact approximations for the fluxes on the face.</li>
<li>After touchFaceLastTime: Send out the projected data to neighbouring trees if we employ domain decomposition. This happens automatically and is championed by Peano's core. The step works with consolidated data, as touchFaceLastTime() happens after touchCellLastTime().</li>
</ol>
</li>
<li>Secondary sweep<ol type="a">
<li>Before touchFaceFirstTime(), we merge incoming data from other tree partitions. From hereon, we have a valid, consistent view of the predicated data on a face from the left and right side. This step is championed by Peano's core.</li>
<li>touchFaceFirstTime(): Solve the Riemann problem and store the outcome within the face.</li>
<li>touchCellFirstTime(): We know that touchFaceFirstTime() has already been called for the 2d adjacent faces of the cell. Therefore, we can now correct the solution. This step also could be realised within touchCellLastTime().</li>
</ol>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md905"></a>
Alternatives</h3>
<p>For a serial code, we could solve the Riemann problem straightaway in touchFaceLastTime(). touchFaceLastTime() is invoked after touchCellLastTime() (see Peano's <a class="el" href="../../da/d1b/peano_action_sets.html">generic description of the order of events over action sets</a>) has been called for both adjacent cells. While this is an appealing idea, as it means that we could throw away the projected data and keep only the Riemann solve result, this would break down in a parallel setup, where each subdomain has to send out its contribution first and we then have to merge these partial data sets prior to the next grid sweep.</p>
<h3><a class="anchor" id="autotoc_md906"></a>
Adaptive mesh refinement</h3>
<p>In the context of adaptive meshes, it is important to take into account that</p>
<ul>
<li>hanging faces are not persistent in-between two mesh traversals;</li>
<li>we run through the spacetree in a top-down order.</li>
</ul>
<p>This is reflected by the <a class="el" href="../../da/d1b/peano_action_sets.html">order of the events</a>. Therefore, whenever we project a solution onto a hanging face in step (1), this information will be lost after this mesh traversal. We have to save it by moving the information from the face to the next coarser level.</p>
<p>A straightforward implementation of ADER-DG for adaptive meshes hence commits to a <em><b>solve Riemann problem only on persistent faces and project outcome onto hanging faces</b></em> policy:</p>
<ol type="1">
<li>Primary sweep<ul>
<li>When a hanging face is destroyed, we project the valid half of the projected solution onto the next coarser level.</li>
<li>At the end of the primary sweep, all persistent faces have valid projected data, even though some of these data might be concatenated from finer, hanging faces.</li>
</ul>
</li>
<li>Secondary sweep<ul>
<li>Solve the Riemann problem on the persistent faces, i.e. over the restricted projected solutions.</li>
<li>Project the outcome of the Riemann solve into hanging faces within createHangingFace. There's no need to solve the Riemann problem here once more, as we now have already the valid outcome and can make that one feed into the correction step.</li>
</ul>
</li>
</ol>
<p>Unfortunately, it seems that some solvers suffer from inaccurate Riemann solutions that arise from the interpolation. While we are unsure exactly what causes this our current assumption is that this is caused by one of two things: either the concatenation of the fine faces or solving the problem on the coarse face causes information to move too quickly, therefore forming important gradients that lead to instabilities.</p>
<div class="image">
<img src="../../ader-instability-00.png" alt=""/>
</div>
 <div class="image">
<img src="../../ader-instability-01.png" alt=""/>
</div>
<p>If we want to solve the Riemann problem on the fine (hanging) faces, we have to be very careful:</p>
<ul>
<li>We do not know the order of the mesh travesal events. Notably, we cannot assume that all adjacent cells of a hanging face have already been traversed when we enounter destroyHangingFace, as one adjacent cell is coarser than the other face's cell. The solution is therefore in general not available. Hence, we cannot solve the Riemann problem in the primary sweep. It would also violate the validity of the realisation in a parallel environment.</li>
<li>If we manage somehow to realise the Riemann solves within the second mesh traversal we have to get this outcome back onto the coarser face for the correction of the adjacent coarser cell. The correction can be moved into touchCellLastTime but we cannot guarantee whether the coarser adjacent cell has been traversed before (aka its touchCellLastTime has been called before) or not becaue we do not know in which order the traversal automaton descends into the different branches of the spacetree. If it has been the cell could not make use of the solution in that grid traversal anymore.</li>
</ul>
<p>Therefore, a fine grid solve is only possible if we modify our algorithm blueprint:</p>
<ol type="1">
<li>In the <em><b>primary</b></em> sweep, we run the predictors and project the outcomes onto the faces. Projections onto hanging faces will be lost, but we know that each persistent face will contain valid data from all adjacent cells now if these cells are fine grid cells i.e. carry a solution. This step is not modified.</li>
<li>In the <em><b>secondary</b></em> sweep, we<ul>
<li>solve the Riemann problem on all persistent faces in touchFaceFirstTime.</li>
<li>interpolate the solution of coarser levels onto the hanging faces in createHangingFace;</li>
<li>rerun the prediction for cells which are adjacent to a hanging face. Due to this step, every hanging face now has a valid solution representation from the left and the right side before we destroy the face.</li>
<li>run the Riemann solve for all \( 2d \) adjacent faces of a cell which is adjacent to an AMR boundary (aka hanging face). This is done only(!) for these cells. One could check each of the adjacent faces if they are hanging or not to avoid redundant calculations. This is an optimisation.</li>
<li>run the correction immediately for those cells which are adjacent to hanging faces. For all the other cells, the corrector is not called yet. In particular, it is not called in the coarser cells adjacent to an AMR boundary, as this would result in incorrect data, since the fine grid solutions haven't been restricted yet.</li>
<li>restrict the outcome of the Riemann solve within destroyHangingFace. This restriction overwrites or corrects the fluxes onto the coarser face and ensures that all fluxes are consistent.</li>
</ul>
</li>
<li>In the <em><b>tertiary</b></em> sweep, we<ul>
<li>apply the corrector to all cells which are not adjacent to hanging faces on their level.</li>
</ul>
</li>
</ol>
<p>There is a price to pay for this realisation: Some predictions are done twice (along the AMR boundary) and we traverse the mesh thrice rather than twice. The latter is mitigated by the fact that we can work with smart pointers for the actual data, i.e. not that much data is shoveled through the memory subsystem, but it is a severe overhead. The former can likely be optimized by recognizing whether we are adjacent to a hanging face, which is not yet available. Given that the predictor is by far the most expensive operation in Ader-DG, this optimization should be quite a priority. Nevertheless, it makes sense to maintain both ADER-DG realisation variants: One working with two sweeps and one working with three sweeps. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d3/d82/page_exahype2_home.html">ExaHyPE 2</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:04 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
