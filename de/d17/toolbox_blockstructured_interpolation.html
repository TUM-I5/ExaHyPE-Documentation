<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/d17/toolbox_blockstructured_interpolation.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Halo layer interpolation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When we create hanging faces, we have to interpolate from coarse to fine.</p>
<h2><a class="anchor" id="autotoc_md250"></a>
Data storage scheme</h2>
<p>For a setup with p volumes per coordinate axis per patch, a face always stores \( 2k \cdot p^{d-1} \) values: It stores a layer of depth k of its left neighbouring cell and a layer of the right one. These layers are copies. By separating the copies of halo layers from the actual patch data, we can easier move data around in a parallel computer. A patch only has to know some of the data from all neighbouring, face-connected patches. With our scheme, it does not need to know these neighbours at all. It is sufficient to take the faces of a cell and to use the data from there to reconstruct the actual patch plus its halo layer:</p>
<div class="image">
<img src="../../Interpolation00.png" alt=""/>
</div>
<p>In the image above, we see a schematic illustration of the data layout: In this example, a 2d cell hosts a 5x5 grid of finite volumes and we work with an overlap of k=1. The four faces each hold 2x5 volumes. These are copies from the left and right adjacent cells. So the dark red volumes are actually copies of the volumes within the patch. In the left image, I use a darker grey to label those volumes within the patch which also have been copied by the patch onto the face.</p>
<p>So the four faces hold replicated data from their adjacent cells. When we want to run the <a class="el" href="../../d5/d0e/namespaceRusanov.html">Rusanov</a> solver, e.g., we need information from the neighbouring cells. Peano does not directly use the neighbours but instead uses the replicated data from the faces to supplement the neighbour information. In this illustration, the dark data are used to re-construct the halo. Only half of the face data is used for this reconstruction. The other half is used by the respective other neighbours.</p>
<p>When we now look at hanging faces, we recognise that we need interpolated data from the coarser level:</p>
<div class="image">
<img src="../../Interpolation01.png" alt=""/>
</div>
<p>Hanging faces do not carry any information, i.e. there is no red data in the plots on the right. Only the face on the coarser level holds data. So we have to project the light red volumes down to the fine grid light red volumes, before we can update the fine grid patches (grey).</p>
<p>The <a class="el" href="../../df/d2a/Interpolation_8h.html">Interpolation.h</a> header file hosts a set of interpolation routines.</p>
<h2><a class="anchor" id="autotoc_md251"></a>
Finding the grid topology</h2>
<p>To understand the implementation of the routines, we have to reiterate that we work cell-wisely in Peano. That is, we start from a particular cell that has a father-cell. It is one out of 3^d child cells, as we work with three-partitioning. Within this cell (which is encoded within marker as we will discuss later), we have 2d faces. If one of them is a hanging face (along an AMR transition), Peano will call an interpolation routine for it. The faces of any cell in Peano are enumerated in the same way: <a class="el" href="../../d3/db7/classFace.html">Face</a> 0 is the face whose normal points along the first coordinate axis and which is left in the coordinate system. <a class="el" href="../../d3/db7/classFace.html">Face</a> 1 is the face whose normal points along the second coordinate axis, and so forth. In 2d, face 0 is the left one, face 1 is the bottom one, face 2 is the right one, and face 3 finally the top face.</p>
<p>We can ask the marker which face we are talking about via getSelectedFaceNumber(). We can also ask the marker how this face is positioned within the grid of siblings, i.e. within a 3x3x3 grid. The routine for this is getRelativePositionWithinFatherCell(). In the example above, this routine would return (0,0), (0,1) or (0,2), respectively, Once we know the local face number and this position within 3x3x3 grid, we know the exact grid topology of a hanging face.</p>
<p>I originally thought I could work with interpolating only half of the halo layer. Indeed, we only have to interpolate half of the halo layer along a hanging face: the outer part. This outer data will be used to construct a halo around the adjacent fine grid patch. However, I need the interpolation of all data whenever I create a new persistent face, restricting to half of the halo does not make the code any simpler, and along the domain boundary, e.g., some routines appreciate if they have all interpolation available.</p>
<p>So while I could, in most cases, use the information of the normal to only write half of the halo data (for example only the bright red volumes on the fine mesh in the sketch above), I usually set all the face data on the hanging face, even though half of it is not used.</p>
<h2><a class="anchor" id="autotoc_md252"></a>
Face data enumeration</h2>
<p>All face data are always enumerated lexicographically. That is, 0 is always the left bottom volume within the face data. Then we follow the x-axis, then the y-axis.</p>
<p>The image below shows the enumeration:</p>
<div class="image">
<img src="../../Interpolation02.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md253"></a>
Interpolation as matrix-vector product</h2>
<p>We can always interpret the interpolation as a matrix-vector product. For a system with N unknowns, it is important to recognise that we basically do the same interpolation N times. This is a batched operation, i.e. we compute</p>
<p class="formulaDsp">
\[  u_h = P u_H \]
</p>
<p>for N versions of \( u_h \) and \( u_H \). Peano's tarch component has a routine for batched multiplication, where you pipe in a set of \( u_H \) vectors and you get a set of \( u_h \) vectors out.</p>
<h2><a class="anchor" id="autotoc_md254"></a>
Interpolation flavours</h2>
<p>Each interpolation type is realised via three different routes. All flavours follow the same naming convention.</p>
<ul>
<li>Each routine starts with the prefix interpolate.</li>
<li>There's always one flavour that's then called interpolateCell, the other one is called interpolateHaloLayer.</li>
<li>I add the data storage format that underlies the operator realisation. At the moment, I only support array of struct (AoS).</li>
<li>The storage format identifier is followed by another underscore.</li>
<li>The next part of the string is the actual interpolation scheme.</li>
</ul>
<p>We offer two types of interpolation: There's a few hard-coded interpolation schemes which are written in core C++ and realise the interpolation. There is also a generic verison of the interpolation which expects the user to pass in an interpolation matrix and then applies this matrix instead of a hard-coded operation.</p>
<p>If you work with the generic implementation accepting matrices, then most codes pre-compute the required matrices manually (within a Python script, e.g.) and then pass in a pointer to a constant double field holding the matrix. Please consult toolbox::blockstructured::interpolateHaloLayer_AoS_generic() for details.</p>
<p>Technically, there are always two types of interpolation routines per face: There is a version which is given the coarse cell face only. I use this one to interpolate from a coarse level onto a face at the boundary of a finer \(
3 \times 3 \) patch. The other variant of the interpolation is used for an interior face within a \( 3 \times 3 \) patch and is also given the coarse cell data. The latter variant is only called to create new faces. It is never used for hanging faces.</p>
<p>For this one, I have to create the fine grid volumetric data, and then copy the interpolated data from there onto the face data. This way, we are consistent with the idea that face data always holds copies from adjacent fine grid data.</p>
<h2><a class="anchor" id="autotoc_md255"></a>
Caching of inter-grid transfer operators (only for built-in C++ operators)</h2>
<p>Constructing the interpolation operators can be time consuming. I therefore cache the operators.</p>
<p>For the handling of faces at the boundary of the \( 3 \times 3 \times 3 \) patches, I hold one large interpolation matrix per normal. So for 2d, I have four interpolation matrices, for 3d I have six. The large interpolation matrix per direction can compute all \( 3^{d-1} \) faces in one rush, so we usually only need one out of them at a time. So I have this huge map with these matrices. When we have to interpolate, we first check whether we've already assembled the matrix. If so, we use this one. If not, we first compute it and cache it in the map.</p>
<p>For the volumetric interpolation and the handing of the interior faces, we use another map. That is, if we want to compute the interior face, we first project onto a temporary \( 3^d \) set of volumes, and then we extract the fine face data from there. This implies that we are consistent with the actual projection of face data, where we take fine grid volume values and write them onto the face data as copies. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d7/d66/page_toolbox_home.html">Toolbox</a></li><li class="navelem"><a class="el" href="../../dd/d28/toolbox_blockstuctured.html">Blockstructured</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:28:57 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
