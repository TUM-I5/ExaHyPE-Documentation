<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d42/tutorials_documentation_multigrid_petsc_discontinuous_galerkin_poisson.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Discontinuous Galerkin for the Poisson equation with PETSc</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We solve the Poisson equation</p>
<p>\( -\Delta u = 4 \pi^2 \prod_{d} \sin (2 \pi x_d) \)</p>
<p>over the unit square or cube \( \Omega = [0,1]^d \), subject to Dirichlet boundary conditions \( u |_{\partial \Omega} = 0 \). The exact solution of this problem is \( u_{\mathrm{exact}} = \prod_d \sin (2 \pi x_d) \)</p>
<p>Things that you should be familiar with before you read this tutorial:</p>
<ul>
<li>Peano's <a class="el" href="../../de/d44/page_multigrid_terminology.html">multigrid terminology</a>;</li>
<li>DG basics (from a math point of view, though no in-depth knowledge is required);</li>
<li>How to install and build Peano and notably how to enable its <a class="el" href="../../d2/d05/documentation_multigrid_petsc.html">PETSc backend</a>.</li>
</ul>
<p>This simple example discusses the steps and code snippets from the file benchmarks/multigrid/petsc/poisson/dg.py. We omit some technical details (such as the parsing of the command line) and focus on key ingredients. Therefore, it is reasonable to study this description in combination with the actual script. It is best to read all high-level documentation in combination with the documentation of the class multigrid.petsc.solvers.DiscontinuousGalerkinDiscretisation which provides a lot of details on the actual implementation and mathematical ingredients. This page is more on the how to use the class to construct a working solver.</p>
<h1><a class="anchor" id="autotoc_md631"></a>
High level overview of Python script structure</h1>
<h2><a class="anchor" id="autotoc_md632"></a>
Set up the project</h2>
<p>First, we have to create a multigrid project.</p>
<div class="fragment"></div><!-- fragment --><p>This is kind of an empty hull until we fill it with some global information (such as the domain size) and also tell the API to scan the global Makefile.</p>
<p>We will insert the solvers into this project in a minute. Once this is done, we need to configure the project</p>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="autotoc_md633"></a>
Introduce the solver</h2>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000045">Todo</a></b></dt><dd>Change the arguments' names to the "from" notation.</dd></dl>
<p>A DG solver is created through</p>
<div class="fragment"></div><!-- fragment --><p>We discuss the details of the parameters below, as they depend - to some degree - upon the chosen Riemann solver. For the time being, it is sufficient to recognise that we create a solver object, instruct it about the matrices/operators that are to be used, and the add it to the PETSc project.</p>
<h2><a class="anchor" id="autotoc_md634"></a>
Deliver C++ code</h2>
<p>Finally, we can ask the PETSc project to build a Peano project which we can translate into C++. So we have a multilevel architecture: A high-level, PETSc-specific view is used to construct the solver. Peano's Python API breaks it down into a Peano representation which is a conceptual/logical representation of the final C++ code. This Peano project then is used to actually write all code snippets and glue code to end up with a genuine C++ application. You can then either compile the code via a plain Makefile through the Python API or you switch to the command line. All of these steps follow the generic architecture of any Peano project.</p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="autotoc_md635"></a>
Created C++ code</h1>
<p>Once the script has terminated, a lot of subdirectories will be there in your project repository. They contain glue code and usually don't have to be inspected. There are four files which represent your solver: An abstract solver class AbstractDGPoisson (with a header and an implementation) and its implementation DGPoisson (header plus implementation).</p>
<p>You should never edit the abstract class, as it is overwritten every time you invoke the Python script. However, it is worth having a look: This abstract superclass contains all the matrices, constants, ... That is, it picks up the details from the Python script.</p>
<p>The actual implementation is something you can edit and alter. Unless you prescribe a right-hand side (not done in the example discussed), this is the place where you introduce your problem-specific right-hand side. It is also the place where you inject Dirichlet Boundary conditions for example.</p>
<h1><a class="anchor" id="autotoc_md636"></a>
Solver flavours</h1>
<h2><a class="anchor" id="autotoc_md637"></a>
Naïve DG discretization of the Poisson equation</h2>
<p>Here we demonstrate how a simple weak formulation resulting from the classical Poisson equation can be implemented within the solver interface.</p>
<div style="background-color: #ffc0cb; padding: 10px; border: 1px solid black;"> We emphasize that this straightforward discretization cannot be used to build a working solver since it leads to a singular matrix! However, it is instructive to discuss it as a first simple example to illustrate the general structure and design philosophy of the solver. The naïve discretisation is then extended to the correct Interior penalty formulation at the end of this tutorial. </div><p>Throughout the tutorial, we follow the notation as used for <a href="file:///home/tobias/git/Peano/doxygen-html/html/dd/dfd/classpetsc_1_1solvers_1_1DiscontinuousGalerkinDiscretisation_1_1DiscontinuousGalerkinDiscretisation.html#details">multigrid.petsc.solvers.DiscontinuousGalerkinDiscretisation</a> and discuss 2D Poisson equation with \( \mathcal{L}(u) = -\Delta u = - \nabla ^2 u = - \partial_x^2 u - \partial_y^2 u \). The extension to higher dimensions is straightforward. Multiplying by a test-function \( v \) and integrating by parts, our weak formulation becomes</p>
<p class="formulaDsp">
\begin{eqnarray*}
  \int _\Omega \mathcal{L}(u) \cdot v \ d\boldsymbol{x} 
  &amp;=&amp; 
  \int _\Omega ( -\Delta u) \cdot v \ d\boldsymbol{x} 
  \\ 
  &amp;=&amp; 
  \sum_{\text{cells } K} \int _{K} (- \Delta u) \cdot v \ d\boldsymbol{x} 
  \\ 
  &amp;=&amp; 
  \sum_{\text{cells } K} 
  \left( 
  \int _{K} ( \nabla u, \nabla v) \ d\boldsymbol{x} 
  - 
  \int _{\partial K} (\widehat{\nabla u},n) \cdot v \ ds 
  \right)
  =
  \sum_{\text{cells } K} \int _{K} f \cdot v \ d\boldsymbol{x}  
\end{eqnarray*}
</p>
<p> The Dirichlet boundary condition \( u |_{\partial \Omega} = 0 \) is enforced weakly. However, we will defer a discussion of how this is implemented to the next section where we introduce the interior penalty method. In the facet integrals \( \int_{\partial K} \) of the above expression, \( n \) denotes the outward normal of the cell \( K \). The term \( ( \nabla u, n) \), which results from the integration by parts, needs to be evaluated on the cell boundary \( \partial K \). For interior faces this is not defined since the solution is allowed to be discontinuous across cells' boundaries in the DG approach. Hence, we need to replace \( \nabla u \) by some \( \widehat{\nabla u} \) as discussed in the following. First, we introduce the vector \( n_F\) on each facet. On boundary facets we set \( n_F = n \) such that \( n_F \) is the outward normal vector. For all interior facets there are two outward normals, one associated with each of the two neighbouring cells, and we need to make a choice. If the facet is oriented such that its normal points in coordinate direction \( j \) then \( n_F\) is the unit vector with 1 at position \( j \) and zeros everywhere else. For example, in two dimensions we have that \( n_F \in \{(1,0)^T, (0,1)^T\} \) on interior facets. Observe that in this case \( n_F \) and \( n \) only differ by a sign: \( n = \pm n_F \) or more explicitly \( n = n_F (n\cdot n_F) \).</p>
<p>In Peano, we need proceed as follows to deal with the term \( ( \nabla u, n) = ( \nabla u, n_F) (n\cdot n_F) \):</p>
<ul>
<li>First, we introduce projections \( q^- \) and \( q^+ \) of the normal gradient \( ( \nabla u, n_F) \) in the cell onto facets, so that  <p class="formulaDsp">
\begin{equation}
  q^\pm = ( \nabla u, n_F)|_{\partial K}
\end{equation}
</p>
 Mathematically, the projections can be constructed through L-2 projection or extrapolation of the cell values. From the perspective of each individual cell, the projections are distributed as shown in the picture in <a class="el" href="../../de/d44/page_multigrid_terminology.html">enumeration discussion</a>: left and bottom facets are assigned the "+" projection, and top and right facets receive the "-" projections. As a result, each facet stores both \( q^+ \) and \( q^- \) coming from its two neighboring cells (the case of boundary facets will be discussed separately).</li>
<li>Then, on each facet of \( \partial K \), we define \( q^f = \mathcal{R} \left( q^-, q^+ \right) \) and replace the term \( (\widehat{\nabla u},n_F) \) with \( q^f \) in the integrand. The simplest choice of \( \mathcal{R} \) is \( q^f = \left( q^- + q^+ \right) / 2 \), which corresponds to averaging the gradients of two neighbouring cells. So, the weak formulation becomes  <p class="formulaDsp">
\begin{eqnarray*}
  \sum_{\text{cells } K} 
  \left( 
  \int _{K} ( \nabla u, \nabla v) \ d\boldsymbol{x}  
  - 
  \int_{\partial K} q^f  v(n\cdot n_F)\, ds
  \right)
  =
  \sum_{\text{cells } K} \int _{K} f \cdot v \ d\boldsymbol{x} 
\end{eqnarray*}
</p>
</li>
</ul>
<p>Now, we consider the discretization of the problem <em>at the level of an individual cell</em> and its facets, as it gives us the information required for the arguments in <code>multigrid.petsc.solvers.DiscontinuousGalerkinDiscretisation()</code>. We illustrate each components of the solver with an example of a 1st order discretization. As the problem is discretized by choosing appropriate test functions and calculating the integrals, the discussed above weak formulation for an individual cell results in a set of linear equations, which can be written in the matrix form:</p>
<p class="formulaDsp">
\begin{equation}
  \left(
    \begin{array}{cc}
      A_{c \gets c} &amp; A_{c \gets f} \\
    \end{array}
  \right)
  \left(
    \begin{array}{c}
      \bar{u} \\
      \bar{q}^f
    \end{array}
  \right)
  =
  M \bar{f}
\end{equation}
</p>
<p>where \( M \) is the mass matrix that arises from the right hand side of the weak formulation above. The projections of the normal gradient can then be represented as follows</p>
<p class="formulaDsp">
\begin{equation}
  \bar{q}^\pm = P_{f \gets c} \bar{u}
\end{equation}
</p>
<p>The bar notation of \( \bar{u} \), \( \bar{q}^f \), \( \bar{q}^\pm \) here denotes vectors of nodal values of corresponding unknowns for a single representative cell and its faces as illustrated below.</p>
<div class="image">
<img src="../../two-d-1st-order-stencil.png" alt="" width="25%"/>
</div>
<p>Here, \( \bar{u} = \left( u_0, u_1, u_2, u_3 \right) \) (4 unknowns), \( \bar{q}^f = \left( q^f_0, ... , q^f_7 \right) \) (8 unknowns) and \( \bar{q}^\pm = \left( q^+_0, ..., q^+_3 , q^-_4, ..., q^-_7 \right) \) (8 unknowns). Note that the vector \( \bar{q}^\pm \) is composed only of those projections \( q^+_i \) and \( q^-_i \) to which the values from the given cell are projected. As such, we do not count her, for example, \( q^-_0 \) and \( q^+_4 \), as they will be assigned values when accessed from neighbouring cells. On the right-hand side, \( \bar{f} \) is the vector of nodal values of the given function \( f \).</p>
<p>The ingredients required for a DG solver are the following:</p>
<ul>
<li>Each cell holds \( (p+1)^d \) nodes, where the polynomial degree \( p \) is stored in the variable <code> polynomial_degree </code>. In our 2D 1st order example, \( p = 1 \), \( d = 2 \), so each cell has 4 nodes. <br  />
<br  />
</li>
<li>Each node within the cell holds one unknown, as we solve a scalar equation for \( u \). Therefore, <pre class="fragment">    cell_unknowns = 1
</pre> If you have vector-valued PDEs, it is worth studying the documentation of <a href="file:///home/tobias/git/Peano/doxygen-html/html/dd/dfd/classpetsc_1_1solvers_1_1DiscontinuousGalerkinDiscretisation_1_1DiscontinuousGalerkinDiscretisation.html#details">the DG solver itself</a> and notably the section "Data storage" therein. <br  />
<br  />
</li>
<li>On the facets, we have introduced one helper variable \( q^f \) to represent an approximation of the normal component of the gradient vector. Since this is a scalar variable, we set <pre class="fragment">    face_unknowns = 1
</pre> The number of \( q^f \) unknowns per facet is \( (p+1)^{d-1} \), which gives 2 for \( p = 1 \), \( d = 2 \). Additionally, on each facet we store the same number of \( q^- \) and \( q^+ \) projections, which gives extra \( 2(p+1)^{d-1} \) unknowns per facet. <br  />
<br  />
</li>
<li><p class="startli">The operator \( A_{c \gets c} \) takes the dofs within a cell and couples them with each other. It arises from the discretization of the term \( \int _{K} ( \nabla u, \nabla v) \ d\boldsymbol{x} \) and represents a \( (p+1)^{d} \times (p+1)^{d} \) matrix, which should be specified in <code> cell_cell_lhs_matrix </code>. In our example, this is a \( 4 \times 4 \) matrix.</p>
<p class="startli">Additionally, since the supplied matrix is supposed to be mesh-independent and computed for a reference unit square, one needs to indicate how it should be scaled when mapped onto a particular mesh cell with spacing \( h \). This should be done by specifying <em>a power of</em> \( h \) in <code> cell_cell_lhs_matrix_scaling </code>. It is easy to show that for the term \( \int _{K} ( \nabla u, \nabla v) \ d\boldsymbol{x} \) this scaling factor is \( h^{d-2} \), i.e. </p><pre class="fragment">    cell_cell_lhs_matrix_scaling = args.dimensions-2
</pre><p> For two dimensions, it is 0. <br  />
</p>
</li>
<li><p class="startli">The operator \( A_{c \gets f} \) takes the \( 2d(p+1)^{d-1} \) values of \( q^f \) on the faces and couples them with \( (p+1)^{d} \) cell values of \( u \). This is responsible for the face integral term \( \int_{\partial K} q^f v \, ds \) in our weak formulation. Thus, it represents a \( (p+1)^{d} \times 2d(p+1)^{d-1} \) matrix, which is passed on as <code> face_to_cell_matrix </code> with scaling power of \( h \) specified in <code> face_to_cell_matrix_scaling </code>.</p>
<p class="startli">In the 2D 1st order case, this is a \( 4 \times 8 \) matrix, where the first two columns correspond to the integral over the left facet, the next two columns correspond to the bottom facet, followed by the next two columns for the right facet, and the last two columns for the top. See <a class="el" href="../../de/d44/page_multigrid_terminology.html">this page</a> for more details on the enumeration order. <br  />
<br  />
</p>
</li>
<li>The right-hand side operator \( M \) is a \( (p+1)^d \times (p+1)^d \) matrix which is applied to the vector of nodal values \( b \), i.e. function \( f(x) \) evaluated at the Gauss-Lobatto or Gauss-Legendre points of a cell. This default right-hand side is a <em><b>mass matrix</b></em> and scaled with \( h^d \) due to the integral. Consequently, <pre class="fragment">    cell_cell_rhs_matrix_scaling = args.dimensions
</pre> <br  />
</li>
<li>The operator \( P_{f \leftarrow c} \) takes the values from a cell, compute the gradient and projects it onto the faces. Hence, \( P_{f \leftarrow c} \) is a \( 2d(p+1)^{d-1} \times (p+1)^{d} \) matrix. The 2d equals the number of faces of a cell, while the face is a submanifold and therefore hosts \( (p+1)^{d-1} \) values. The result is written into \( q^+ \) or \( q^- \) on the faces, depending on the relative position of the facet within the cell. Read through <a href="file:///home/tobias/git/Peano/doxygen-html/html/dd/dfd/classpetsc_1_1solvers_1_1DiscontinuousGalerkinDiscretisation_1_1DiscontinuousGalerkinDiscretisation.html#details">the DG solver's</a> data storage section and also consult Peano's <a class="el" href="../../de/d44/page_multigrid_terminology.html">enumeration discussion</a> for information on the ordering. In the interface above, \( P_{f \leftarrow c} \) is specified by <code> cell_to_face_matrix </code> with scaling <code> cell_to_face_matrix_scaling </code>. As we compute derivatives, the matrix needs to be scaled by \( 1/h \), so <pre class="fragment">    cell_to_face_matrix_scaling = -1
</pre> For \( p = 1 \) and \( d = 2 \), \( P_{f \leftarrow c} \) is an \( 8 \times 4 \) matrix with the first two lines corresponding to the normal gradient computed for the left facet, with the remaining lines following the same order as earlier discussed for \( A_{c \leftarrow f} \). <br  />
<br  />
</li>
<li>Finally, we need to couple \( q^f \) and \( q^- \), \( q^+ \). For this, we specify <code>face_face_Riemann_problem_matrix</code> that defines the linear relation \( q^f = \mathcal{R} \left( q^- , q^+ \right) = \frac{1}{2} \left( q^- + q^+ \right) \). Unlike the operators \( A_{c \leftarrow f} \) and \( P_{f \leftarrow c} \), which employ unknowns on all the facets of a given cell, this needs to be specified for one representative facet only, assuming that the relation is the same for all interior facets. As such, it requires a \( (p+1)^{d-1} \times 2(p+1)^{d-1} \) matrix. Let us illustrate this with our reference case. Coupling the unknowns on the left facet gives  <p class="formulaDsp">
\begin{equation}
    \left(
      \begin{array}{c}
        q^f_0 \\
        q^f_1
      \end{array}
    \right)
    =
    \left(
      \begin{array}{cccc}
        \frac{1}{2} &amp; \frac{1}{2} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \frac{1}{2} &amp; \frac{1}{2}
      \end{array}
    \right)
    \left(
      \begin{array}{c}
        q_0^- \\
        q_0^+ \\
        q_1^- \\
        q_1^+  
      \end{array}
    \right)
  \end{equation}
</p>
 This \( 2 \times 4 \) matrix needs to be specified as <code>face_face_Riemann_problem_matrix</code> in our case. See Section "The simplest Riemann solver: averaging" for a general discussion.</li>
</ul>
<h3><a class="anchor" id="autotoc_md638"></a>
Global matrix representation</h3>
<p>Denoting the <em>global</em> dof-vectors vectors \( \bar{u}^{\text{global}} \), \( \bar{q}^{f,\text{global}} \) and \( \bar{q}^{\pm,\text{global}} \), the weak formulation is equivalent to the matrix equation</p>
<p class="formulaDsp">
\begin{equation}
\begin{pmatrix}
A_{c\leftarrow c}^{\text{global}} &amp; A_{c\leftarrow f}^{\text{global}} &amp; 0 \\
P_{f\leftarrow c}^{\text{global}} &amp; 0 &amp; -\text{Id} \\
0 &amp; -\text{Id} &amp; R_{f\leftarrow f}^{\text{global}}
\end{pmatrix}
\begin{pmatrix}
\bar{u}^{\text{global}} \\
\bar{q}^{f,\text{global}} \\
\bar{q}^{\pm,\text{global}} \\
\end{pmatrix}
=
\begin{pmatrix}
M^{\text{global}}\bar{f}^{\text{global}} \\ 0 \\ 0
\end{pmatrix}
\end{equation}
</p>
<p> In this expression \( A_{c\leftarrow c}^{\text{global}} \), \( A_{c\leftarrow f}^{\text{global}} \), \( P_{f\leftarrow c}^{\text{global}} \) and \( M^{\text{global}} \) are the globally assembled versions of the cell-local matrices \( A_{c\leftarrow c} \), \( A_{c\leftarrow f} \), \( P_{f\leftarrow c} \) and \( M \) defined above. The matrix \( R_{f\leftarrow f}^{\text{global}} \) arises from the construction \( q^f = \mathcal{R}(q^-,q^+) \) on the facets.</p>
<p>It should be stressed that the construction of the global matrix (or, in a matrix-free approach, the machinery for applying it to a given vector) is handled by Peano, so the matrix equation is written down in abstract form here for future reference and to highlight its general structure. The user only needs to specify the <em>local</em> building block as explained above.</p>
<h2><a class="anchor" id="autotoc_md639"></a>
Interior penalty method for the Poisson equation</h2>
<p>The above discretisation, which averages the normal gradient of two neighbouring cells to obtain a value on the facets has the serious drawback that it leads to a singular matrix. Mathematically, the reason for this is that the weak form does not have a unique solution: given a solution \( u \), we can always obtain another solution \( u&#39; = u+\delta u \) by adding an arbitrary function \( \delta u \) which is piecewise constant on the interior cells. In order to make the DG discretization of the Poisson equation well-defined, we need to modify the weak formulation by introducing two additional terms, "penalizing" jumps of the solution across the faces. This method is known as the interior penalty method, and we will use the formulation summarized in <a href="https://doi.org/10.1002/nla.1816">Bastian, Blatt, Scheichl: Num. Lin. Alg. with Appl., 19(2), pp.367-388 (2012)</a>.</p>
<p>First, we need to introduce some notation. It can be shown that the sum of face integrals in the weak form discussed in the previous paragraph, i.e. \( - \sum_{\text{cells } K} \int _{\partial K} (\widehat{\nabla u},n) \cdot v \ ds \), is equivalent to the following, for the interior facets:</p>
<p class="formulaDsp">
\begin{equation}
  - \sum_{\text{facets } F} \int _{F} \{ (\nabla u, n_F) \} [\![ v ]\!] \ ds
\end{equation}
</p>
<p>Unlike the summation over the cells \( K \), where each facet of the boundary \( \partial K \) is integrated over twice, in this case, we sum over the facets, so each of them is covered only once. This results in the jump and average terms under the integral:</p>
<p class="formulaDsp">
\begin{equation}
  [\![ v ]\!] := v^- - v^+, \quad \{ (\nabla u, n_F) \} := \frac{1}{2} \left( (\nabla u, n_F)^- + (\nabla u, n_F)^+ \right),
\end{equation}
</p>
<p>where the "-"s and "+"s are the values from the two cells sharing the facet, evaluated on this facet. For the vertical facets, the "+" and "-" cells are the right and the left one, respectively, and for the horizontal ones, they correspond to the upper and the lower cells. In our framework, we will use the projection variables for the "+" and "-" values discussed earlier .</p>
<p>Note that the above equivalence of integral terms is consistent with how we defined the averaging flux \( \mathcal{R}\left( q^- , q^+ \right) = \left( q^- + q^+ \right) / 2 \). If we want to use another relation for \( \mathcal{R} \), we will need to redefine the \( \{ \cdot \} \).</p>
<p>In these terms, the full formulation for our problem reads as follows</p>
<p class="formulaDsp">
\begin{multline}
  \sum_{\text{cells } K} 
  \int _{K} ( \nabla u, \nabla v) \ d\boldsymbol{x} 
  +
  \sum_{\text{interior facets } F_i}
  \int _{F_i}
  \biggl[
    - \{ (\nabla u, n_F) \} [\![ v ]\!] 
    + \theta [\![ u ]\!] \{ (\nabla v, n_F) \}
    + \gamma_F [\![ u ]\!] [\![ v ]\!] 
  \biggr] \ ds
  +
  \\
  \sum_{\text{boundary facets } F_b}
  \int _{F_b}
  \biggl[
    - (\nabla u, n_F) \, v 
    + \theta \, u \, (\nabla v, n_F)
    + \gamma_F u v
  \biggr] \ ds
  =
  \sum_{\text{cells } K} \int _{K} f v \ d\boldsymbol{x},
\end{multline}
</p>
<p> where \( \theta \) and \( \gamma_F \) are user-defined constant penalty parameters. We will consider \( \theta = 1 \) and \( \gamma_F = p (p + d - 1) / h = 2/h \), where \( h \) is the grid spacing. See <a href="https://doi.org/10.1002/nla.1816">Bastian, Blatt, Scheichl: Num. Lin. Alg. with Appl., 19(2), pp.367-388 (2012)</a> and reference therein for details on the choice of penalty parameters.</p>
<p>To implement this formulation in a solver, we will use the same notation and follow the same steps as for the "naive discretization" discussed earlier.</p>
<p>First, in addition to the gradient projections \( q^\pm \), we introduce the projections of the solution  </p><p class="formulaDsp">
\begin{equation}
  u^+ := - u |_{\text{left and bottom facet}}, \quad u^- := u |_{\text{right and top facet}}.
\end{equation}
</p>
<p> It is convenient to introduce the opposite signs for the "-" and "+" projections, as we did above, because it will provide the required jumps when summed up. We also introduce \( u^f \), which couples with the projections on each facet in the same way as \( q^f \), i.e. \( u^f = \mathcal{R} \left( u^-, u^+ \right) = \left( u^- + u^+ \right) / 2 \).</p>
<p>The discretized weak formulation takes the following form</p>
<p class="formulaDsp">
\begin{equation}
  \left(
    \begin{array}{cc}
      A_{c \gets c} &amp; A^{\text{penalty}}_{c \gets f} \\
    \end{array}
  \right)
  \left(
    \begin{array}{c}
      \bar{u} \\
      \bar{w}^f
    \end{array}
  \right)
  =
  M \bar{f}
\end{equation}
</p>
<div class="image">
<img src="../../two-d-1st-order-penalty-stencil.png" alt="" width="35%"/>
</div>
<p>We introduced \( \bar{w}^f \) to denote the collection of \( q^f \) and \( u^f \) values as they are intertwined due to the enumeration system used: we first count all the values on the left facet, followed by the bottom, and so on, i.e. \( \bar{w}^f = \left( q_0^f, q_1^f, u_0^f, u_1^f, q_2^f, q_3^f, u_2^f, u_3^f, ... \right)\), which makes 16 unknowns in our example.</p>
<p>The projection equations become</p>
<p class="formulaDsp">
\begin{equation}
  \bar{w}^\pm = P_{f \gets c} \bar{u},
\end{equation}
</p>
<p>where, similarly, the vector \( \bar{w}^\pm \) combines the projection components following the same order: \( \bar{w}^\pm = \left( q_0^+, q_1^+, u_0^+, u_1^+, \quad q_2^+, q_3^+, u_2^+, u_3^+, \quad q_4^-, q_5^-, ... \right) \). Again, here we only include the unknowns that are assigned values when accessed from the given cell: these are the "+" projections for the left and bottom facets, and "-" projections for the right and top. 16 in total.</p>
<p>Now, let us review the components required to build the solver:</p>
<ul>
<li>As in the previous paragraph, we specify the variable <code> polynomial_degree </code> and set <pre class="fragment">    cell_unknowns = 1
</pre> Number of cell unknowns stays the same. <br  />
<br  />
</li>
<li>On the facets, we have, as previously, \( q^f \) and, additionally, \( u^f \), so we now set <pre class="fragment">    face_unknowns = 2
</pre> The number of \( q^f \) and \( u^f \) unknowns together per facet is \( 2(p+1)^{d-1} \), which gives 4 for \( p = 1 \), \( d = 2 \). Additionally, on each facet we store the same number of \( q^-, u^- \) and \( q^+, u^+ \) projections, which gives extra \( 4(p+1)^{d-1} \) unknowns per facet. <br  />
<br  />
</li>
<li>The operator \( A_{c \gets c} \) remains the same as in the previous paragraph. The penalty terms do not affect the cell-cell coupling. <br  />
<br  />
</li>
<li><p class="startli">The operator \( A^{\text{penalty}}_{c \gets f} \) is an extended version of the operator \( A_{c \gets f} \) of the classical weak formulation, which incorporates the penalty terms. It takes the \( 4d(p+1)^{d-1} \) values of \( q^f \) and \( u^f \) on the faces and couples them with \( (p+1)^{d} \) cell values of \( u \). It represents a \( (p+1)^{d} \times 4d(p+1)^{d-1} \) matrix, which is passed on as <code> face_to_cell_matrix </code>.</p>
<p class="startli">This operator now has a part that couples \( u \) with \( q^f \) and another part that couples \( u \) with \( u^f \). The first, "classical", component under the boundary integral is responsible for coupling \( u \) and \( q^f \): When computed for a given cell boundary, it gives the terms \( \pm \int q^f v \, ds \).</p>
<p class="startli">Both penalty terms couple \( u \) and \( u^f \). They result from the integrals like \( \pm \theta \int u^f ( \nabla v, n) \, ds \pm 2 \gamma_F \int u^f v \, ds \). In the 2D 1st order case, this is a \( 4 \times 16 \) matrix, which is divided into segments as shown in the picture: blue segments result from the standard flux integral, and the green ones result from the summed-up penalty terms.</p>
</li>
</ul>
<div class="image">
<img src="../../penalty-matrix.png" alt="" width="45%"/>
</div>
<p> <br  />
</p>
<p>As one can see, the blue segments needs to be scaled by \( h \). A potential issue with the current approach to scaling in the interface becomes evident when we look at the green segments. Each green entity is a sum of two penalty terms, one of which should be scaled by \( h^0 \) (no scaling) and another one by \( h \). It means that, in the general case, we cannot separate this scaling without passing the information about \( h \) to the matrix generator, which we want to avoid.</p>
<p>In our case, this issue is resolved by choosing the penalty parameter \( \gamma_F \sim 1/h \), which is consistent with the literature and ensures that the entire green segment has the same scaling factor \( h^0 \).</p>
<p>However, we still need different scaling factors for the blue ( \( h^1 \)) and green ( \( h^0 \)) segments, so we cannot do with just one argument <code> face_to_cell_matrix_scaling </code>, and we split the matrix internally for the purpose of scaling. <br  />
<br  />
</p>
<ul>
<li>The right-hand side operator \( M \) remains the same. <br  />
<br  />
</li>
<li><p class="startli">The operator \( P_{f \leftarrow c} \) needs to be changed to accommodate the projection \( u^\pm \). It is now a \( 4d(p+1)^{d-1} \times (p+1)^{d} \) (i.e. \( 16 \times 4 \)) matrix with the lines arranged according to the order of unknowns in \( \bar{w}^\pm \). This is specified in <code> cell_to_face_matrix </code>.</p>
<p class="startli">Similar to \( A^{\text{penalty}}_{c \gets f} \), the projection matrix will be divided into the segments corresponding to \( q^\pm \) and segments corresponding to \( u^\pm \). The gradient-related \( q^\pm \) segments, as previously, should be scaled by \( h^{-1} \), while the \( u^\pm \) part does not need to be scaled ( \( h^0 \)). <br  />
<br  />
</p>
</li>
<li>Finally, we need to extend the <code>face_face_Riemann_problem_matrix</code> to include the relation \( u^f = \left( u^- + u^+ \right) / 2 \). This gives a \( (p+1)^{d-1} \times 4(p+1)^{d-1} \) matrix:  <p class="formulaDsp">
\begin{equation}
    \left(
      \begin{array}{c}
        q^f_0 \\
        u^f_0 \\
        q^f_1 \\
        u^f_1
      \end{array}
    \right)
    =
    \left(
      \begin{array}{cccccccc}
        \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{1}{2} \\
      \end{array}
    \right)
    \left(
      \begin{array}{c}
        q_0^- \\
        u_0^- \\
        q_1^- \\
        u_1^- \\
        q_0^+ \\
        u_0^+ \\
        q_1^+ \\
        u_1^+ \\ 
      \end{array}
    \right)
\end{equation}
</p>
 See Section "The simplest Riemann solver: averaging" for a general discussion on the implementation of the face-face coupling.</li>
</ul>
<h3><a class="anchor" id="autotoc_md640"></a>
Treatment of boundary faces and boundary conditions</h3>
<p>While on the interior faces we construct \( q^f=\mathcal{R}(q^-,q^+)\), \( u^f =\mathcal{R}(u^-,u^+)\) from pairs of values \( q^\pm \), \( u^\pm \) obtained from the two neighbouring cells, the boundary faces need to be treated differently. For this we set \( q^f = q^+ \), \( u^f = u^+ \) for the left and bottom facets and \( q^f = q^- \), \( u^f = u^- \) for the right and top facets.</p>
<p>Since Peano stores pairs of variables \( u^\pm \) and \( q^\pm \) on <em>all</em> faces, this means that the linear system no longer contains equations for the variables \( q^- \), \( u^- \) for the left and bottom facets and \( q^+ \), \( u^+ \) for the right and top facets. This is expressing the fact that these variables do not have any physical meaning and are decoupled from the solution. As a consequence, they can be set to arbitrary values. To prevent the system matrix from becoming singular, we simply insert 1s into the relevant positions of the global matrix. This implies that if the corresponding entries of the right hand side vector are set to zero, the redundant variables will also be zero. This treatment of boundary values is implemented in python/multigrid/petsc/actionsets/ImposeDirichletBoundaryConditionsWithInteriorPenaltyMethod.py</p>
<p>To see understand the treatment of boundary conditions it is instructive to consider the general case where \( u|_{\partial \Omega} = g \) for some arbitrary function \( g \). As described in <a href="https://doi.org/10.1002/nla.1816">Bastian, Blatt, Scheichl: Num. Lin. Alg. with Appl., 19(2), pp.367-388 (2012)</a>, the boundary condition is enforced weakly by adding the following expression to the right hand of the weak formulation:</p>
<p class="formulaDsp">
\begin{equation}
\sum_{\text{boundary facets } F_b}
  \int _{F_b}
  \biggl[    
    \theta \, g \, (\nabla v, n_F)
    + \gamma_F g v
  \biggr] \ ds
\end{equation}
</p>
<p>In our case \( g=0 \), so this term vanishes. It is also worth pointing out that Neumann boundary conditions can be enforced in a similar way, see <a href="https://doi.org/10.1002/nla.1816">Bastian, Blatt, Scheichl: Num. Lin. Alg. with Appl., 19(2), pp.367-388 (2012)</a> for details.</p>
<h3><a class="anchor" id="autotoc_md641"></a>
Global matrix representation</h3>
<p>Again, we can write down a the matrix equation for the <em>global</em> dof-vectors vectors \( \bar{u}^{\text{global}} \), \( \bar{w}^{f,\text{global}} \) and \( \bar{w}^{\pm,\text{global}} \) which is equivalent to the weak formulation. This matrix equation is</p>
<p class="formulaDsp">
\begin{equation}
\begin{pmatrix}
A_{c\leftarrow c}^{\text{global}} &amp; A_{c\leftarrow f}^{\text{penalty,global}} &amp; 0 \\
P_{f\leftarrow c}^{\text{global}} &amp; 0 &amp; -\text{Id} \\
0 &amp; -\text{Id} &amp; R_{f\leftarrow f}^{\text{global}}
\end{pmatrix}
\begin{pmatrix}
\bar{u}^{\text{global}} \\
\bar{w}^{f,\text{global}} \\
\bar{w}^{\pm,\text{global}} \\
\end{pmatrix}
=
\begin{pmatrix}
M^{\text{global}}\bar{f}^{\text{global}} \\ 0 \\ 0
\end{pmatrix}
\end{equation}
</p>
<p> where construction of the <em>global</em> matrices are is handled by Peano. The matrix \( R_{f\leftarrow f}^{\text{global}} \) takes into account the correct treatment of redundant variables on boundary faces as discussed above.</p>
<h2><a class="anchor" id="autotoc_md642"></a>
The simplest Riemann solver: averaging</h2>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000046">Todo</a></b></dt><dd><p class="startdd">Tobias. Continue writing. </p>
<p class="enddd">This section needs to be revisited or moved. </p>
</dd></dl>
<ul>
<li>On the faces, we have the gradient \( \nabla u \) from the left and from right right. So we might be tempted to hold \( \nabla u^+ \) and \( \nabla u^- \). So \( 2d \) quantities in total. However, this is not necessary: We are really only interested in the gradient along the normal. Therefore, we set <pre class="fragment">    face_unknowns = 1 
</pre> These are not really unknowns in the linear algebra sense. They are helpers. <br  />
</li>
<li>The operator \( A_{ff} \) takes the \( 2(p+1)^{d-1} \) on the face and yields the \( (p+1)^{d-1} \) averages. In the interface, it is specified by the parameter <code> face_face_Riemann_problem_matrix </code>.</li>
</ul>
<p>The treatment of the face terms differs from Riemann solver to Riemann solver.</p>
<p>This discussion follows the Discontinuous Galerking discussion. The only difference is that we have to extend our averaging such that both solution components, i.e. \( u \) and the normal projection of the \( \phi \) are taken into account:</p>
<p class="formulaDsp">
\begin{eqnarray*}
  \int_{\partial \text{cell}_{\psi _\phi }} (n \cdot \phi) \psi _\phi dS(x)  
  &amp; \approx &amp; 
  \int_{\partial \text{cell}_{\psi _\phi }} [[ (\phi,n) ]] \psi _\phi dS(x)  
  =
  \pm
  \frac{1}{2} \int_{\partial \text{cell}_{\psi _\phi }} \left( \phi ^+ + \phi ^- \right) \psi _\phi dS(x)  
  \\
  \int _{\partial \text{cell}_{\psi _u}}  u \cdot (n, \psi _u) dS(x)
  &amp; \approx &amp; 
  \int _{\partial \text{cell}_{\psi _u}}  [[u]] \cdot (n, \psi _u) dS(x)
  = 
  \frac{1}{2}
  \int _{\partial \text{cell}_{\psi _u}}  (u^- + u^+) \cdot ( n, \psi _u ) dS(x)
\end{eqnarray*}
</p>
<p>The image below illustrates this:</p>
<div class="image">
<img src="../../average_gradient.png" alt=""/>
</div>
<p>Neither the solution nor the gradient exist at the cell boundaries. We have to average both of them.</p>
<p>There are two ways to implement this scheme:</p>
<ol type="1">
<li>We don't use any constraint equation (see continuous case), but let the face-to-cell projection use the average of left and right value.</li>
<li>We introduce a helper dof.</li>
</ol>
<p>The first variant is close-to-trivial and certainly a good sanity check. The face-to-face matrix here is empty/zero, but the user has to take the averaging into account within the projection matrix.</p>
<p>The second variant is more sophsticiated, yet allows users later to implement more sophisticated schemes aka Riemann solvers. We have already gone down this route by introducing dedicated "helper" dofs on the face.</p>
<p class="formulaDsp">
\begin{eqnarray*}
  \begin{pmatrix}
  \frac{1}{2} &amp; 0 &amp; 0 &amp; 0     &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0     &amp; 0 &amp; 0 &amp; 0 &amp; 0   &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; \frac{1}{2} &amp; 0 &amp; 0     &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0     &amp; 0 &amp; 0 &amp; 0 &amp; 0   &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 0               &amp; 0 &amp; 0 &amp; 0 &amp; 0               &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0     &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 0               &amp; 0 &amp; 0 &amp; 0 &amp; 0               &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0     &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 
  \end{pmatrix}
\end{eqnarray*}
</p>
<p>The first two rows refer to projected values from the left. They are sole input values (should be brought to the right by the solver in this context) and hence not subject to any additional equations. The third line averages the \( u \) values from left and right, the fourth line addresses the normal projections of \( \phi \).</p>
<p>In the example above, we use d-linear shape functions arranged along the Gauss-Lobatto integration points. So the two nodes carrying the shape function weights are spread out over the unit interval.</p>
<div class="image">
<img src="../../face_to_face_projection.png" alt=""/>
</div>
 <div class="image">
<img src="../../piecewise_discontinuous_shape_functions.png" alt=""/>
</div>
 <div class="image">
<img src="../../projection.png" alt=""/>
</div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d3/da3/page_multigrid_home.html">MGHyPE</a></li><li class="navelem"><a class="el" href="../../d4/d49/page_mghype_tutorials.html">Tutorials</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:00 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
