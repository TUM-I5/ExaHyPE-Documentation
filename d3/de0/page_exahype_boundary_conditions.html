<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/de0/page_exahype_boundary_conditions.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Boundary conditions</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Boundary conditions often are tricky to implement and solely up to the user. In , Dirichlet and Neumann boundary conditions on Cartesian meshes are close to trivial. More sophsticated boundary conditions require slightly more work. Here are some remarks how to implement them.</p>
<p>The boundary condition semantics are solely determined by the user's boundary condition callback. Therefore, it is possible to use different boundary conditions in different domain areas.</p>
<p>![ 's Finite Volume scheme organises its mesh into patches. Here, we use a 5$\times$5 patch (orange/red). Prior to the update of a patch, Â calls <code>boundaryConditions</code> for each of the volumes adjacent to the boundary (darker red). The routine allows you to alter the value of the halo surrounding the patch (blue). The outer (blue) cells are subsequentially used to determine a flow through the boundary into the domain. [[figure:exahype:boundary-conditions]]{#figure:exahype:boundary-conditions label="figure:exahype:boundary-conditions"} ](documentation/exahype2/boundary.pdf){#figure:exahype:boundary-conditions width="20%"}</p>
<p>Boundary conditions in general are realised via their own callback called <code>boundaryConditions</code>. When you run the Python toolkit, you get an empty implementation of this routine that you can befill. The routine is called per outer volume (Figure 1.1{reference-type="ref" reference="figure:exahype:boundary-conditions"}) or per degree of freedom in the Discontinuous Galerkin schemes.</p>
<h3><a class="anchor" id="autotoc_md856"></a>
Boundary conditions on unit box for Finite Volume schemes</h3>
<p><a class="anchor" id="autotoc_md857"></a> </p><h5>Dirichlet boundary conditions</h5>
<p>Dirichlet boundary conditions $$Q(x) | _{\partial \Omega } = f(x,t)$$ are close to trivial to implement. You set outer values of the halo layer due to</p>
<p>void ...::MySolver::boundaryConditions( ... ) Qoutside[0] = ... Qoutside[1] = ... ...</p>
<p>Obviously, the values on the right-hand side can depend on time and spatial position. We find two different ways to impose Dirichlet conditions:</p>
<ol type="1">
<li>You simple set the outer volumes (blue in Figure 1.1{reference-type="ref" reference="figure:exahype:boundary-conditions"}) to $f(x,t)$.</li>
<li>You compute the average between the blue value and the interior value as $Q | _{\partial \Omega } = \frac{1}{2} (Q_{\text{outside}} + Q_{\text{inside}}) = f(x,t)$ which yields $Q_{\text{outside}} = 2f(x,t)-Q_{\text{inside}}$.</li>
</ol>
<p>The latter formula is inspired by Finite Differences and might give a slightly more accurate values. With a sole averaging Riemann solver, it directly sets the flux. If you use something like <a class="el" href="../../d5/d0e/namespaceRusanov.html">Rusanov</a>, you might tweak $Q_{\text{outside}}$ further such that the eigenvalue term along the boundary face has the correct (imposed) value too.</p>
<p><a class="anchor" id="autotoc_md858"></a> </p><h5>Neumann boundary conditions</h5>
<p>As we can read the volume values inside the domain prior to a time step and modify those outside of the domain, it is straightforward to implement homogeneous Neumann conditions. The snippet below implements homogeneous Neumann conditions</p>
<p>$$\left( \nabla Q(x), n \right) | _{\partial \Omega } = 0$$</p>
<p>void ...::MySolver::boundaryConditions( ... ) Qoutside[0] = Qinside[0]; Qoutside[1] = Qinside[1]; ...</p>
<p>but obviously you can use a simple Finite Differences scheme to impose non-homogeneous conditions as well.</p>
<p><a class="anchor" id="autotoc_md859"></a> </p><h5>Inflow/outflow conditions</h5>
<p>Inflow or outflow boundary conditions are conceptually close to Neumann conditions. Often, it is however reasonable to supplement them with some limiter, i.e.Â if the flow is close to zero and inwards, a modified outflow condition could manually set it (limit it) to zero.</p>
<p>While this approach does work in most of the cases, it struggles to handle information flow that is not orthogonal to the Cartesian faces. It assumes that all flow is axis-aligned: You can only modify the face-connected neighbour volume in the ghost region outside of the domain. You cannot alter diagonal volumes. Unless you want to use distorted, i.e.Â boundary-aligned, meshes as discussed below, there's no way around this. Yet, increasing the domain size usually helps in such a case.</p>
<h3><a class="anchor" id="autotoc_md860"></a>
More complex boundaries</h3>
<p><a class="anchor" id="autotoc_md861"></a> </p><h5>Extrapolating boundary data</h5>
<p>It is more complicated to realise boundary conditions that extrapolate data into the outside. Such boundary conditions read as $$Q(x) | _{\partial \Omega } = \lim _{x \mapsto \partial \Omega} Bnd(Q(x,t),\nabla f(Q(x,t)) \ \text{or} \ \left( \nabla Q(x), n \right) | _{\partial \Omega } = \lim _{x \mapsto \partial \Omega} Bnd(Q(x,t),\nabla f(Q(x,t)).$$ It is obviously trivial to extrapolate the solution value within the domain to the boundary volumes (dark red to blue value in Figure 1.1{reference-type="ref" reference="figure:exahype:boundary-conditions"}), but once you need the derivatives at the boundaries, you have to invest more work. After all, the boundary routine only provides access to the boundary data, but not to any derivatives.</p>
<p>Users have successfully implemented non-homogeneous Neumann boundary conditions where they extrapolate the derivatives onto the boundary and use those to inform the actual value. This requires work however:</p>
<ul>
<li>Introduce a new material parameter that stores the directional derivative. If you need the non-homogeneous Neumann conditions all around the domain, you will need <code>Dimensions</code> material parameter per unknown:</li>
<li>Compute the derivatives per volume after each time step in a Finite Differences sense. We can add such a code snippet in Python:</li>
<li>With this information, we can finally set the boundary conditions: The routine <code>boundaryConditions</code> is given the data at the boundary. Due to our modifications, these data are augmented by additional "material" parameters[^2] which store the derivatives from the current time step. We can thus realise boundary conditions which use the (boundary-extrapolated) derivative besides the actual value.</li>
</ul>
<p><a class="anchor" id="autotoc_md862"></a> </p><h5>Boundary-aligned non-cubic geometries</h5>
<p>'s mesh is topologically Cartesian. That does not mean that you have to work in a Cartesian world. You can distort, squeeze, rotate the mesh locally as long as your mesh topology remains adaptive Cartesian. Codes like the <a class="el" href="../../da/da9/namespaceExaSeis.html">ExaSeis</a> simulation package introduce material parameters per degree of freedom to encode mesh distortions. This allows them to represent a boundary exactly, i.e.Â to adopt the Cartesian mesh to the real domain boundaries. Obviously, the actual boundary condition implementations then have to be adopted accordingly, too.</p>
<p><a class="anchor" id="autotoc_md863"></a> </p><h5>Distinguishing different boundary types</h5>
<p>Some solvers require different boundary conditions in different areas. We distinguish two different paradigms to realise this:</p>
<ol type="1">
<li>compute boundary type on-the-fly;</li>
<li>map boundary type onto marker.</li>
</ol>
<p>Each boundary condition callback is supplemented with spatial data (aka geometry) and time step. These two ingredients allow you to compute the boundary type <em>on the fly</em>: Whenever the boundary data routine is invoked, you read out the coordinate of the boundary face, and then you decide which boundary condition to apply. After all, the realisation of the boundary is totally up to you in the call back, i.e.Â you can have multiple ifs or a case distinction via a switch.</p>
<p>If these case distinctions are something you want to avoid&mdash;as the geometry checks are too expensive or for other reasons&mdash;you can introduce a <em>boundary marker</em>. Â does not have genuine markers, but it does have material parameters. Add an additional material parameter in your solver setup, and initialise this parameter with an integer constant which represents your boundary type. When the actual boundary routine is invoked, the inner degree of freedom will contain this material parameter, i.e.Â you can read it out and make your boundary realisation depend upon its value.</p>
<h3><a class="anchor" id="autotoc_md864"></a>
A complete swap out of boundary conditions</h3>
<p>So far, all boundary conditions have relies on a call-back principle: The user supplements an implementation of the (point-wise) boundary data behaviour, and there is some generic kernel which runs over the boundary and calls this implementation. This means, Â has to anticipate what kind of information the user might need when they implement their boundary data.</p>
<p>The current interface for boundary conditions is more or less tailored towards stationary boundary data. As soon as you need some time-dependent behaviour on the boundary such as ODEs (Sommerfeld boundary conditions, e.g.), you might be well-advised to swap out the whole boundary implementation.</p>
<p>Every Â solver has an attribute <code>_action_set_handle_boundary</code>. This is the action set that we invoke to handle the boundary. It has an attribute <code>TemplateHandleBoundary_KernelCalls</code> which is a string in jinja2 format. It is used to actually generate the kernel call. By default, it invokes the <code>applyBoundaryConditions</code> function of your solver. You can redirect this call:</p>
<p>The start of the attribute with an underscore emphasises that I usually do not expect users to alter the action set. This is for experienced users. Most of them will create their own subclass of the solver. In this case, an attribute with an underscore make sense.</p>
<p>Â comes along with a limited set of pre-manufactured boundary conditions. What is available in which content depends strongly on the solver type used. Consult the documentation of the <code>HandleBoundary.h</code> file of your solver type. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li><li class="navelem"><a class="el" href="../../d3/d82/page_exahype2_home.html">ExaHyPE 2</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:04 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
