<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../Peano-icon.png" type="image/x-icon" />
<title>Peano</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="../../doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="../../toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<!-- https://bryce.io/gitlab-corners/ -->
<style>.gitlab-corner-wrapper{overflow:hidden;width:100px;height:100px;position:absolute;top:0;right:0}.gitlab-corner{position:absolute;top:-16px;right:-50px;transform:rotate(45deg);background:#333;border:44px solid #333;border-bottom:none;border-top:#333 solid 16px}.gitlab-corner svg{width:60px;height:60px;margin-bottom:-4px}.cls-1{fill:#fc6d26}.cls-2{fill:#e24329}.cls-3{fill:#fca326}.gitlab-corner:hover .cls-1{animation:cycle .6s}.gitlab-corner:hover .cls-2{animation:cycleMid .6s}.gitlab-corner:hover .cls-3{animation:cycleEnd .6s}@keyframes cycle{100%,15%,60%{fill:#fc6d26}30%,75%{fill:#e24329}45%,90%{fill:#fca326}}@keyframes cycleMid{100%,15%,60%{fill:#e24329}30%,75%{fill:#fca326}45%,90%{fill:#fc6d26}}@keyframes cycleEnd{100%,15%,60%{fill:#fca326}30%,75%{fill:#fc6d26}45%,90%{fill:#e24329}}@media (max-width:500px){.gitlab-corner:hover .cls-1,.gitlab-corner:hover .cls-2,.gitlab-corner:hover .cls-3{animation:none}.gitlab-corner .cls-1{animation:cycle .6s}.gitlab-corner .cls-2{animation:cycleMid .6s}.gitlab-corner .cls-3{animation:cycleEnd .6s}}</style><div class="gitlab-corner-wrapper"><a href="https://gitlab.lrz.de/hpcsoftware/Peano" class="gitlab-corner" aria-label="View source on GitLab"><svg id="logo_art" data-name="logo art" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 586 559"><g id="g44"><path id="path46" class="cls-1" d="M461.17,301.83l-18.91-58.12L404.84,128.43a6.47,6.47,0,0,0-12.27,0L355.15,243.64H230.82L193.4,128.43a6.46,6.46,0,0,0-12.26,0L143.78,243.64l-18.91,58.19a12.88,12.88,0,0,0,4.66,14.39L293,435,456.44,316.22a12.9,12.9,0,0,0,4.73-14.39"/></g><g id="g48"><path id="path50" class="cls-2" d="M293,434.91h0l62.16-191.28H230.87L293,434.91Z"/></g><g id="g56"><path id="path58" class="cls-1" d="M293,434.91,230.82,243.63h-87L293,434.91Z"/></g><g id="g64"><path id="path66" class="cls-3" d="M143.75,243.69h0l-18.91,58.12a12.88,12.88,0,0,0,4.66,14.39L293,435,143.75,243.69Z"/></g><g id="g72"><path id="path74" class="cls-2" d="M143.78,243.69h87.11L193.4,128.49a6.47,6.47,0,0,0-12.27,0l-37.35,115.2Z"/></g><g id="g76"><path id="path78" class="cls-1" d="M293,434.91l62.16-191.28H442.3L293,434.91Z"/></g><g id="g80"><path id="path82" class="cls-3" d="M442.24,243.69h0l18.91,58.12a12.85,12.85,0,0,1-4.66,14.39L293,434.91l149.2-191.22Z"/></g><g id="g84"><path id="path86" class="cls-2" d="M442.28,243.69h-87.1l37.42-115.2a6.46,6.46,0,0,1,12.26,0l37.42,115.2Z"/></g></svg></a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Peano-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Peano
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/d83/page_compiler_specific_settings_home.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Vendor Software Stacks and System- and Compiler-specific Settings</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md799">Realisation of Peano&#39;s internal compiler-specific switches</a></li>
<li class="level1"><a href="#autotoc_md800">Vendor toolchains and compiler settings</a><ul><li class="level2"><a href="#autotoc_md801">GNU</a><ul><li class="level3"><a href="#autotoc_md802">OpenMP and OpenMP offloading</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md803">Intel (oneAPI)</a><ul><li class="level3"><a href="#autotoc_md804">Intel toolchain</a></li>
<li class="level3"><a href="#autotoc_md805">Intel-specific compiler flags</a></li>
<li class="level3"><a href="#autotoc_md806">The loggers</a></li>
<li class="level3"><a href="#autotoc_md807">Threading Building Blocks (TBB)</a></li>
<li class="level3"><a href="#autotoc_md808">OpenMP and OpenMP offloading</a></li>
<li class="level3"><a href="#autotoc_md809">SYCL and SYCL offloading</a></li>
<li class="level3"><a href="#autotoc_md810">MPI</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md811">LLVM</a><ul><li class="level3"><a href="#autotoc_md812">OpenMP</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md813">NVIDIA NVC++ (NVHPC)</a><ul><li class="level3"><a href="#autotoc_md814">NVIDIA toolchain</a></li>
<li class="level3"><a href="#autotoc_md815">OpenMP and OpenMP offloading</a></li>
<li class="level3"><a href="#autotoc_md816">OpenMP and std::par offloading</a></li>
<li class="level3"><a href="#autotoc_md817">Source code annotation</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md818">AMD</a><ul><li class="level3"><a href="#autotoc_md819">OpenMP and OpenMP offloading</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><ul>
<li>tarch_accelerator_SYCL </li>
<li><a class="el" href="../../d6/d5c/page_machines.html">Reference Configurations for Some Machines</a></li>
</ul>
<p>Peano has three different approaches how to handle system- and compiler-specific settings and properties:</p>
<ul>
<li>Most of the system-specific information should be specified through CXXFLAGS or LDFLAGS, i.e. when you configure the original setup. These flags as well as all the information about enabled toolboxes, extensions, and so forth are dumped into the config.h and the Makefiles. C++ codes will read config.h to take the settings into account, and the Python API will parse the generated Makefile to extract the relevant info and use it for all codes built on top of Peano, too.</li>
<li>At compile time, the system will furthermore read out the compiler version, and it will include the compiler-specific settings for this particular compiler. This allows Peano to use certain defines for certain compiler flavours.</li>
<li>Peano offers special toolchains for special vendors.</li>
</ul>
<p>The page below discusses these particular toolchains and provides some information on settings for some vendors. There is a dedicated <a class="el" href="../../d6/d5c/page_machines.html">subpage for some machines</a> that we use quite a lot for Peano. Before we dive into particular toolchains, some general remark on how the compiler-dependencies are managed:</p>
<h1><a class="anchor" id="autotoc_md799"></a>
Realisation of Peano's internal compiler-specific switches</h1>
<p>Peano relies on a header <a class="el" href="../../da/d5d/CompilerSpecificSettings_8h.html">tarch/CompilerSpecificSettings.h</a>. This header reads out the compiler version and includes a particular flavour of the header for this compiler, i.e. the header reads out some compiler preprocessor directives and then includes the one it find most appropriate. You may always include your own file derived from one of the other headers in the directory.</p>
<p>Whenever we find incompatibilities between different compilers, we try to resolve them through defines within the compiler-specific settings. This way, we avoid that some "fixes" are spread over the whole code. The setting also are used to configure for particular machine specifica such as default alignment. Most expressions within the compiler-specific settings header can manually be overwritten via defines. Consult the file implementation for details.</p>
<p>The config.h as generated by the build system also feeds into the compiler-specific settings. First of all, it defines a few generic constants such as SharedTBB or Parallel. These are classic macro symbols. Whenever certrain macro combinations have knock-on effects on other features, they should be covered within CompilerSpecificSettings and in turn be mapped onto further macros.</p>
<p>There are exceptions to this rule: If you have a certain GPU backend, you might have to annotate functions in a certain way. Such information is not covered within CompilerSpecificSettings (it has nothing to do with a particlar compiler choice), but is found directly within the headers of the respective namespace in the technical architecture.</p>
<h1><a class="anchor" id="autotoc_md800"></a>
Vendor toolchains and compiler settings</h1>
<h2><a class="anchor" id="autotoc_md801"></a>
GNU</h2>
<h3><a class="anchor" id="autotoc_md802"></a>
OpenMP and OpenMP offloading</h3>
<div class="fragment"><div class="line">CC=gcc CXX=g++ ./configure --with-multithreading=omp --with-gpu=omp CFLAGS=<span class="stringliteral">&quot;-O3 -W -Wall -Wno-attributes -fopenmp -foffload=nvptx-none -march=native&quot;</span> CXXFLAGS=<span class="stringliteral">&quot;-std=c++20 -O3 -W -Wall -Wno-attributes -fopenmp -foffload=nvptx-none -march=native&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-fopenmp -foffload=nvptx-none -march=native -mtune=native&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md803"></a>
Intel (oneAPI)</h2>
<h3><a class="anchor" id="autotoc_md804"></a>
Intel toolchain</h3>
<p><img src="https://upload.wikimedia.org/wikipedia/en/f/fa/OneAPI-rgb-3000.png" alt="" width="10%" class="inline"/></p>
<p>Peano provides support for Intel's (oneAPI) toolchain through two routes: The ITAC interface and the Instrumentation and Tracing Technology (ITT). To activate either of these toolchains, you have to reconfigure with one of the two options below:</p>
<div class="fragment"><div class="line">./configure ... --with-toolchain=itac</div>
<div class="line">./configure ... --with-toolchain=itt</div>
</div><!-- fragment --><p>Broadly speaking, the toolchains alters the code in two ways:</p>
<ul>
<li>It enables ITAC or ITT.</li>
<li>It switches the line logger to the ITAC or ITT logger. That is, trace data are not pipes onto the terminal anymore, but are passed into the ITAC or ITT API.</li>
<li>It adds some Intel-specific compile flags.</li>
</ul>
<p>The enumeration shows that the name Intel toolchain is misleading. We are actually not tailoring the build to the Intel toolchain, but we tailor the setup to the Intel analysis tools. Most production runs will not use the Intel toolchain, but rather set all Intel-specific flags for compiler and linker manually.</p>
<h3><a class="anchor" id="autotoc_md805"></a>
Intel-specific compiler flags</h3>
<p>At the moment, we add the following flags to the compile when the Intel toolchain is activated:</p>
<ul>
<li>We add <div class="fragment"><div class="line">CXXFLAGS=<span class="stringliteral">&quot;... -DTBB_USE_THREADING_TOOLS -parallel-source-info=2&quot;</span></div>
</div><!-- fragment --> to all compiles.</li>
<li>We add <div class="fragment"><div class="line">CXXFLAGS=<span class="stringliteral">&quot;... -DTBB_USE_ASSERT&quot;</span></div>
</div><!-- fragment --> to all debug and assert builds.</li>
</ul>
<h3><a class="anchor" id="autotoc_md806"></a>
The loggers</h3>
<p>Even though you have switched to the Intel loggers, you will not get any trace information if you build in release mode. You have to switch to the trace mode (or assertions or debug) - compare general remarks on <a class="el" href="../../db/d3f/page_architecture_home.html">Peano's build modi</a> - to get traces or annotation info.</p>
<p>Once you try to trace your code with the Intel tool, the size of the traces quickly becomes unmanageable or the performance might go down. Therefore, we disable the trace by default. The first trace command will then enable it.</p>
<p>For further discussion on logging, please see the <a class="el" href="../../d1/d9e/tarch_logging.html">generic logging description for Peano</a>.</p>
<h3><a class="anchor" id="autotoc_md807"></a>
Threading Building Blocks (TBB)</h3>
<p>We found that the newer Intel compilers provide a flag</p>
<div class="fragment"><div class="line">CXXFLAGS=<span class="stringliteral">&quot;... -tbb&quot;</span> LDFLAGS=<span class="stringliteral">&quot;... -tbb&quot;</span></div>
</div><!-- fragment --><p>which means you don't have to manually link against TBB anymore. It also should provide all the includes. It is not clear what flags are set (might be more than only a few include paths), so we found this route more reliable rather than adding TBB paths and libraries manually.</p>
<h3><a class="anchor" id="autotoc_md808"></a>
OpenMP and OpenMP offloading</h3>
<div class="fragment"><div class="line">CC=icx CXX=icpx ./configure --with-multithreading=omp --with-gpu=omp CFLAGS=<span class="stringliteral">&quot;-O3 -W -Wall -Wno-attributes -fiopenmp -fopenmp-targets=spir64&quot;</span> CXXFLAGS=<span class="stringliteral">&quot;-std=c++20 -O3 -W -Wall -Wno-attributes -fiopenmp -fopenmp-targets=spir64&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-march=native -mtune=native -fiopenmp -fopenmp-targets=spir64&quot;</span></div>
</div><!-- fragment --><p>Intel suggests to use -fiopenmp for performance and features: <a href="https://www.intel.com/content/www/us/en/developer/articles/guide/porting-guide-for-icc-users-to-dpcpp-or-icx.html">https://www.intel.com/content/www/us/en/developer/articles/guide/porting-guide-for-icc-users-to-dpcpp-or-icx.html</a></p>
<h3><a class="anchor" id="autotoc_md809"></a>
SYCL and SYCL offloading</h3>
<p>SYCL is directly supported via icpx. There are only a few things to do:</p>
<ul>
<li>Translate your code with &ndash;with-multithreading=sycl and/or &ndash;with-gpu=sycl.</li>
<li>Add CXXFLAGS="... -fsycl" to your compiler flags. This way, all the headers of SYCL are known to icpx.</li>
<li>Add LDFLAGS="... -fsycl" to your linker flags. This way, the linker will automatically add all SYCL libraries. Furthermore, it will know when it builds the final applications that it should embed both the device kernels and the CPU kernels into the executable. If you use LIBS="... -lsycl", the linking will succeed, but the very first time you invoke a SYCL kernel, you'll get a message similar to <div class="fragment"><div class="line">terminate called after throwing an instance of <span class="stringliteral">&#39;sycl::_V1::runtime_error&#39;</span></div>
<div class="line">  what():  No kernel named _ZTSZZN7toolbox15blockstructured64interpolateCellDataAssociatedToVolumesIntoOverlappingCell_linearEiiiiiPKdPdN6peano45utils15LoopParallelismEENKUlRT_E_clIN4sycl3_V17handlerEEEDaS8_EUlNSC_2idILi3EEEE_ was found -46 (PI_ERROR_INVALID_KERNEL_NAME)</div>
<div class="line">Aborted (core dumped)</div>
</div><!-- fragment --></li>
<li>Ensure CXX=icpx points to the icpx compiler.</li>
<li>Ensure CC=icx points to the icpx compiler if you work with the autotools. This is not intuitive and actually quite a hack, but you need it to work: <code>configure</code> will test if you C compiler is compatible with your linker flags. However, the <code>-fsycl</code> command is unknown to the default C compiler (usually gcc) and your configure will fail miserably. By letting the C compiler variable point to the Intel oneAPI C compiler, you ensure that the sanity check within the configuration phase passes.</li>
<li>Reset the MPI compiler (see below; if you want to use MPI).</li>
</ul>
<p>For Intel GPUs:</p>
<div class="fragment"><div class="line">CC=icx CXX=icpx ./configure --with-multithreading=sycl --with-gpu=sycl CFLAGS=<span class="stringliteral">&quot;-O3 -W -Wall -Wno-attributes -fsycl -fsycl-targets=spir64 -fsycl-device-code-split -fp-model=consistent&quot;</span> CXXFLAGS=<span class="stringliteral">&quot;-std=c++20 -O3 -W -Wall -Wno-attributes -fsycl -fsycl-targets=spir64 -fsycl-device-code-split -fp-model=consistent&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-march=native -mtune=native -fsycl -fsycl-targets=spir64 -fsycl-device-code-split -fp-model=consistent&quot;</span></div>
</div><!-- fragment --><p>For NVIDIA GPUs (Intel LLVM, Codeplay):</p>
<div class="fragment"><div class="line">CC=icx CXX=icpx ./configure --with-multithreading=sycl --with-gpu=sycl CFLAGS=<span class="stringliteral">&quot;-O3 -W -Wall -Wno-attributes -fsycl -fsycl-targets=nvptx64-nvidia-cuda -fsycl-device-code-split -fp-model=consistent -Xsycl-target-backend=nvptx64-nvidia-cuda --cuda-gpu-arch=sm_XX&quot;</span> CXXFLAGS=<span class="stringliteral">&quot;-std=c++20 -O3 -W -Wall -Wno-attributes -fsycl -fsycl-targets=nvptx64-nvidia-cuda -fsycl-device-code-split -fp-model=consistent -Xsycl-target-backend=nvptx64-nvidia-cuda --cuda-gpu-arch=sm_XX&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-march=native -mtune=native -fsycl -fsycl-targets=nvptx64-nvidia-cuda -fsycl-device-code-split -fp-model=consistent -Xsycl-target-backend=nvptx64-nvidia-cuda --cuda-gpu-arch=sm_XX&quot;</span></div>
</div><!-- fragment --><p>where XX has to be replaced by the actual compute capability of the device.</p>
<p>For AMD GPUs (Intel LLVM, Codeplay):</p>
<div class="fragment"><div class="line">CC=icx CXX=icpx ./configure --with-multithreading=sycl --with-gpu=sycl CFLAGS=<span class="stringliteral">&quot;-O3 -W -Wall -Wno-attributes -fsycl -fsycl-targets=amdgcn-amd-amdsha -fsycl-device-code-split -fp-model=consistent -Xsycl-target-backend=amdgcn-amd-amdsha --offload-arch=gfxXXX&quot;</span> CXXFLAGS=<span class="stringliteral">&quot;-std=c++20 -O3 -W -Wall -Wno-attributes -fsycl -fsycl-targets=amdgcn-amd-amdsha -fsycl-device-code-split -fp-model=consistent -Xsycl-target-backend=amdgcn-amd-amdsha --offload-arch=gfxXXX&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-march=native -mtune=native -fsycl -fsycl-targets=amdgcn-amd-amdsha -fsycl-device-code-split -fp-model=consistent -Xsycl-target-backend=amdgcn-amd-amdsha --offload-arch=gfxXXX&quot;</span></div>
</div><!-- fragment --><p>where XXX has to be replaced by the actual compute capability of the device.</p>
<h3><a class="anchor" id="autotoc_md810"></a>
MPI</h3>
<p>Intel's MPI wrapper is mpiicpc even though they now want you to use icpx instead of icc/icpc. To tell the MPI wrapper that you want to use icpx, you have to set some environment variables:</p>
<div class="fragment"><div class="line"><span class="keyword">export</span> I_MPI_CXX=icpx</div>
<div class="line">./configure --with-mpi=mpiicpc</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md811"></a>
LLVM</h2>
<h3><a class="anchor" id="autotoc_md812"></a>
OpenMP</h3>
<p>For NVIDIA GPUs:</p>
<div class="fragment"><div class="line"><span class="keyword">export</span> MARCH=sm_XX</div>
<div class="line">CC=clang CXX=clang++ ./configure --with-multithreading=omp --with-gpu=omp CXXFLAGS=<span class="stringliteral">&quot;-std=c++17 -O3 -W -Wall -Wno-attributes -fopenmp -fopenmp-targets=nvptx64-nvidia-cuda -Xopenmp-target=nvptx64-nvidia-cuda -march=$MARCH&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-march=native -mtune=native -fopenmp -fopenmp-targets=nvptx64-nvidia-cuda -Xopenmp-target=nvptx64-nvidia-cuda -march=$MARCH&quot;</span></div>
</div><!-- fragment --><p>where XX has to be replaced by the actual compute capability of the device.</p>
<p>Note: We set the C++ compiler standard to 17. This is due to an issue with LLVM Clang itself. See <a href="https://github.com/llvm/llvm-project/issues/61327">https://github.com/llvm/llvm-project/issues/61327</a>.</p>
<h2><a class="anchor" id="autotoc_md813"></a>
NVIDIA NVC++ (NVHPC)</h2>
<p><img src="https://www.nvidia.com/content/dam/en-zz/Solutions/about-nvidia/logo-and-brand/01-nvidia-logo-vert-500x200-2c50-p@2x.png" alt="" width="20%" class="inline"/></p>
<p>The NVIDIA toolchain requires us to make <code>CXX</code> and <code>CC</code> point to the C++ compiler, as both are passed the same arguments by configure, which are actually only understood by the C++ version.</p>
<h3><a class="anchor" id="autotoc_md814"></a>
NVIDIA toolchain</h3>
<p>Yet to be written. There is an <a class="el" href="../../d1/d9e/tarch_logging.html">NVIDIA logger</a> offered.</p>
<h3><a class="anchor" id="autotoc_md815"></a>
OpenMP and OpenMP offloading</h3>
<p>NVIDIA's compiler does not support all of OpenMP. Therefore, its OpenMP implementation is rather picky when it comes to taskloops and other C++ features. Peano has internal workarounds for all of these items, i.e. the build should in principle succeed yet the code might be slightly slower than the Intel or native Clang counterpart.</p>
<p>The OpenMP offloading requires us to specify both the GPU OpenMP target and a corresponding compute capability:</p>
<div class="fragment"><div class="line">CC=nvc++ CXX=nvc++ ./configure --with-multithreading=omp --with-gpu=omp CFLAGS=<span class="stringliteral">&quot;-O3 -W -Wall --diag_suppress=unrecognized_attribute -fopenmp -Munroll=c:100 -mp=gpu -gpu=ccXX&quot;</span> CXX=<span class="stringliteral">&quot;nvc++&quot;</span> CXXFLAGS=<span class="stringliteral">&quot;-std=c++20 -O3 -W -Wall --diag_suppress=unrecognized_attribute -fopenmp -Munroll=c:100 -mp=gpu -gpu=ccXX&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-march=native -mtune=native -fopenmp -Munroll=c:100 -mp=gpu -gpu=ccXX&quot;</span></div>
</div><!-- fragment --><p>where XX has to be replaced by the actual compute capability of the device.</p>
<h3><a class="anchor" id="autotoc_md816"></a>
OpenMP and std::par offloading</h3>
<div class="fragment"><div class="line">CC=nvc++ CXX=nvc++ CFLAGS=<span class="stringliteral">&quot;-O3 -W -Wall --diag_suppress=unrecognized_attribute -fopenmp -Munroll=c:100 -mp=gpu -gpu=ccXX&quot;</span> CC=<span class="stringliteral">&quot;nvc&quot;</span> CXXFLAGS=<span class="stringliteral">&quot;-std=c++20 -O3 -W -Wall --diag_suppress=unrecognized_attribute -fopenmp -Munroll=c:100 -mp=gpu -stdpar=gpu -gpu=ccXX&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-march=native -mtune=native -fopenmp -Munroll=c:100 -mp=gpu -gpu=ccXX&quot;</span></div>
</div><!-- fragment --><p>where XX has to be replaced by the actual compute capability of the device.</p>
<h3><a class="anchor" id="autotoc_md817"></a>
Source code annotation</h3>
<p>NVIDIA's NVPTX logging is supported by picking the</p>
<div class="fragment"><div class="line">--with-toolchain=nvptx</div>
</div><!-- fragment --><p>toolchain.</p>
<h2><a class="anchor" id="autotoc_md818"></a>
AMD</h2>
<p>For the AMD toolchain we need to load either ROCm or AOMP. Both modules should have AMD's version of Clang. With the AMD toolchain we use AMD's modified Clang. We again need to point <code>CXX</code> and <code>CC</code> to the AMDClang compiler.</p>
<h3><a class="anchor" id="autotoc_md819"></a>
OpenMP and OpenMP offloading</h3>
<p>For the configuration with OpenMP GPU offloading, we again specify <code>--with-gpu=omp</code> to make Peano GPU aware. Furthermore, we need to add AMD specific offloading instructions:</p>
<div class="fragment"><div class="line">CC=amdclang CXX=amdclang++ ./configure --with-multithreading=omp --with-gpu=omp CFLAGS=<span class="stringliteral">&quot;-O3 -W -Wall -Wno-attributes -fopenmp --offload-arch=gfxXXX -D__AMDGPU__&quot;</span> CXXFLAGS=<span class="stringliteral">&quot;-std=c++17 -O3 -W -Wall -Wno-attributes -fopenmp -lstdc++fs --offload-arch=gfxXXX -D__AMDGPU__&quot;</span> LDFLAGS=<span class="stringliteral">&quot;-march=native -mtune=native -lstdc++fs -fopenmp --offload-arch=gfxXXX&quot;</span></div>
</div><!-- fragment --><p>where XXX has to be replaced by the actual compute capability of the device.</p>
<p>Note: We define the preprocessor flag <b>AMDGPU</b> to allow Peano for compiling patches that are needed only for the AMD toolchain. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Peano</a></li>
    <li class="footer">Generated on Tue Jul 1 2025 11:29:03 for Peano by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
